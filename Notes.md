# MySQL "Изучаем SQL". Автор книги: Алан Болье.

## Лайфхаки и тонкости.
Большинство реализаций SQL воспринимают /* ... */ как комментарий

Некоторые СУБД обязывают в запросе к себе указывать FROM и название таблицы.
Например СУБД Oracle. Для того, чтобы только вызвать встроенную функцию, Oracle
предоставляет таблицу dual с единственной строкой данных. Поэтому вызов функции
now() в Oracle Database выглядит следующим образом:

```
SELECT now() FROM dual;
```

При хранении строк возникают закономерные проблемы: строковые символы, иногда
даже одинакового значения, будут представлены в памяти во- первых по разному, а
во- вторых скорее всего с разным объемом занимаемой памяти. Виной всему в этом
несовершенном виде кодировки (сами по себе они то не виноваты, а скорее даже
полезны. Просто попали под горячую руку). Так вот, чтобы узнать, какие кодировки
доступны в MySQL необходимо ввести следующую инструкцию: 

```
SHOW CHARACTER SET;
mysql> SHOW CHARACTER SET;
+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |
```

При сортировке или группировке текстовых данных в MySQL используются только
первые 1024 байта. Это значение может быть увеличено.

## Типы данных.

### Символьные данные.

Символьные данные хрянятся в виде строк фиксированной или переменной длины.
Отличие строк с фиксированной длинной заключается в том, что они справа
дополняются пробелами, а также всегда занимают одно и то же число байт.

Задать ограничение на длину можно следующим образом:

```
char(20) /*Фиксированная длина */
varchar(20) /*Пременная длина*/
```

В MySQL существуют ограничения: char ограничен 255 байтами, а varchar 65535 байтами.

Чтобы указать кодировку, в которой хранится текст, при задании типа столбца необходимо её указать:

```
varchar(20) character set latin1
```

А также можно задать значение кодировки по- умолчанию для всей БД:

```
CREATE DATABASE DB1 CHARACTER SET latin1;
```

Текстовые данные. Данный тип данных позволяет обойти ограничение в 64 КБайт на размер текста. Подразделяется на:
- tinytext	255 Байт;
- text		65 535 Байт
- mediumtext	16 777 215 Байт;
- longtext	4 294 967 295 Байт.

После того, как varchar стал поддерживать до 64 КБайт текстовых данных, смысл в использовании tinytext и text отпал.

### Числовые типы данных.

#### Целые числа.

- tinyint (от -128 до 127), а беззнаковый вариант от 0 до 255
- smallint (от -32 768 до 32 767), а беззнаковый вариант от 0 до 65 535
- mediumint (от -8 388 608 до 8 388 607), а беззнаковый вариант от 0 до 16 777 215
- int (от -2 147 483 648 до 2 147 483 647), а беззнаковый вариант от 0 до 4 294 967 295
- bigint (от -2^63 до 2^63 - 1), а беззнаковый вариант от 0 до 2^64 - 1
Числа с плавающей точкой:
- float (p, s) тут какие- то уж адские диапазоны
- double (p, s)

При указании типа с плавающей точкой можно указать его точность (p - precision).
Это общее число цифр слева и справа от точки. Также можно указать масштаб (s -
scale). Это уже число цифр справа от точки.

#### Данные типа времядата (временнОй тип).
- date		YYYY-MM-DD от 1000-01-01 до 9999-12-31
- datetime	YYYY-MM-DD HH:MI:SS от 1000-01-01 00:00:00.000000 до 9999-12-31 23:59:59.999999
- timestamp 	YYYY-MM-DD HH:MI:SS от 1970-01-01 00:00:00.000000 до 2038-01-18 22:14:07.999999
- year		YYYY от 1901 до 2155
- time		HHH:MI:SSS от -838:59:59.000000 до 838:59:59.000000

СУБД берет на себя задачу по представлению входных данных в виде внутренней
реализации. Условием лишь является подача на вход строковых данных в требуемом
формате. Например для колонки с типом date подойдет такая строка: "2022-01-27"
Типы datetime и timestamp позволяют включать в себя миллионные доли секунды. Для
этого при задании таблицы необходимо указать в скобках трубуемую точность:
datetime (2).

## Создание базы данных.

База создается через конструкцию CREATE DATABASE;

Чтобы переключить контекст на необходимую базу и не вводить её название при
каждом обращении к таблицам внутри, используется конструкция USE 'название_
базы'

## Создание таблицы.

Таблица создается конструкцией CREATE TABLE ();

### Первичный ключ.
Первичный ключ используется для однозначной идетификации записи в таблице.
Первичный ключ должен быть уникальным, не может быть Nullable, а также  в одной
таблице может быть только один первичный ключ.

Первичный ключ можно задать при создании базы, описав его словно колонку:
PRIMARY KEY ('название_колонки' или 'описание_составного_ключа')

Также первичный ключ можно указать уже после создания таблицы через ALTER TABLE:
ALTER TABLE 'название_таблицы' ADD PRIMARY KEY ('название_колонки' или
'описание_составного_ключа')

MySQL позволяет в качестве первичного ключа использовать как и одну из
пользовательских колонок (что далеко не является оптимальным решением), так и
оставить эту задачу на разрешение движком СУБД. Во втором случае предлагается
припихнуть к числовому полю AUTO_INCREMENT

```
CREATE TABLE auto_increment_showing_table 
(
    person_id SMALLINT UNSIGNED AUTO_INCREMENT,
    name VARCHAR(30),
    PRIMARY KEY (person_id)
);
```

### Внешний ключ.
Внешний ключ используется для связи в базовом случае двух таблиц. Например,
существует таблица, хранящая в себе логи. В этой таблице представлены числовые
значения severity и facility. Чтобы иметь возможность транлировать их в
строковые представления создадим две дополнительные таблицы. В одной табличке
будут храниться сопоставления severity, а в другой facility.

```
mysql> create table table_foreig
(
  actor_id int unsigned,
  film varchar(30),
  constraint pk primary key (actor_id, film),
  constraint fk foreign key (actor_id) references table_prim(id));

Query OK, 0 rows affected (0.01 sec)
```

Чтобы задать внешний ключ необходимо создать колонку с такими же параметрами,
как и колонка, на которую этот ключ будет вести. Имеется ввиду тип данных,
ограничение на размер и так далее. После этого при создании новой таблицы
необходимо создать ограничение с помощью ключевого слова **CONSTRAINT**,
обозвать его как- нибудь, к примеру **fk**, что означает foreign key. А уже для
этого ограничения описать внешний ключ. Синтаксис достаточно прост: foreign key
(название_столбца_в_новой_таблице) references другая_таблица(колонка).

> Есть у меня подозрения, что функционал механизма ограничений не заканчивается
> лишь возможностью их создавать. Возможно, в качестве внешнего ключа можно
> применять именованые ограничения первичного ключа, но пока что этот момент не прояснен.

## Запрос SELECT.
При выполнении запроса сервер возвращает **результирующий набор**, а точнее, еще
одну таблицу.

Запрос SELECT состоит из следующих составных частей:
- select определяет, какие столбцы следует включить в результирующий набор;
- from определяет таблицы, из которых следует выбирать данные, а также те
  таблицы, которые должны быть соединены;
- where отсеивает ненужные данные;
- group by используется для группировки строк по общим значениям столбцов;
- having отсеивает ненужные данные;
- order by упорядочивает строки в результирующем наборе по одному или нескольким
  столбцам.

Предложение select, помимо выбора тех столбцов, которые необходимо запросить,
позволяет включать также:
- числовые или строковые литералы;
- выражения (к примеру математические);
- результаты работы вызова встроенных функций;
- результаты работы вызова пользовательских функций.

```
mysql> select language_id,
    'COMMON' language_usage,
    language_id * 3.1415 lang_pi_value,
    upper(name) UpperName
from language;
+-------------+----------------+---------------+-----------+
| language_id | lancuage_usage | lang_pi_value | UpperName |
+-------------+----------------+---------------+-----------+
|           1 | COMMON         |        3.1415 | ENGLISH   |
|           2 | COMMON         |        6.2830 | ITALIAN   |
|           3 | COMMON         |        9.4245 | JAPANESE  |
|           4 | COMMON         |       12.5660 | MANDARIN  |
|           5 | COMMON         |       15.7075 | FRENCH    |
|           6 | COMMON         |       18.8490 | GERMAN    |
+-------------+----------------+---------------+-----------+
```

Таким образом применение select расширяется, позволяя на лету изменять имена
колонок:

```
mysql> select 'bla-bla' bla_bla_column from user_table_1;
+----------------+
| bla_bla_column |
+----------------+
| bla-bla        |
+----------------+
```

А общий синтаксис выглядит как "select (значение из колонки/ результат
выражения/ литерал) (название колонки, куда это будет запихнуто) из таблицы
(название таблицы)"

> Чтобы подчеркнуть изменение имени колонки можно использовать ключевое слово **as**
> между запрашиваемым значением колонки и псевдонимом:

>```
>mysql> select now() as 'Время сейчас';
>+---------------------+
>| Время сейчас        |
>+---------------------+
>| 2023-02-25 02:09:41 |
>+---------------------+
>```


Помимо этого интересно и то, что from является хоть и немаловажной, но вовсе не
обязательной частью запроса SELECT. К примеру, можно запросить вызов встроенных
функций, а в этом случае отпадает необходимость в выборке столбцов из какой-
либо таблицы:

```
mysql> select now(), version(), database();
+---------------------+-----------+------------+
| now()               | version() | database() |
+---------------------+-----------+------------+
| 2023-02-19 00:15:59 | 8.0.32    | sakila     |
+---------------------+-----------+------------+
```

### Удаление дубликатов.

Чтобы избавиться от дубликатов достаточно добавить ключевое слово **distinct**
после предложения **select**:

```
mysql> select * from t1;
+------+
| col1 |
+------+
|    1 |
|    2 |
|    3 |
|    1 |
|    1 |
|    1 |
+------+

mysql> select distinct * from t1;
+------+
| col1 |
+------+
|    1 |
|    2 |
|    3 |
+------+
```

**На самом деле неявно к запросам select пристыковывается ключевое слово all, если**
**не указано другого, например distinct.**

Употребление distinct может заметно негативно повлиять на скорость выполнения
запроса к большому количеству данных по причине того, что оптимизатор выполнит
сортировку, а то и несколько.

### Предложение from.

*Предложение from определяет таблицы, используемые запросом, наряду со
средствами связывания таблиц вместе.*

### Таблицы.

В общем- то неверно думать о таблицах только как о строках, связанных воедино и
хранящихся в базе данных. Это неверно по причине того, что таблиц существует
несколько видов:

- Постоянные таблицы. Они создаются при помощи инструкции CREATE TABLE;
- Произвольные таблицы. Совокупность строк, возвращаемых подзапросами (WHERE,
  HAVING, FROM и так далее). Хранятся исключительно во временной памяти
  вычислительной машины;
- Временные таблицы. Изменяемые данные, хранящиеся в памяти. По сути,
  представляют собой такие же таблицы, но существуют лишь на протяжении времени
  сессии подключения к СУБД;
- Виртуальные таблицы. Создаются с помощью инструкции CREATE VIEW.

И объединяет это все многообразие то, что их можно запихнуть в предложение from.

### Производные таблицы. Таблицы, генерируемые подзапросами.

Подзапрос- запрос, содержащийся в другом запросе. Подзапросы могут быть окружены
скобками. В запросе select подзапросы могут быть встроены во многие места, но в
контексте использования from подзапрос определяет произвольную таблицу, которая
видна из всех других мест запроса.

Иными словами from создает временную таблицу, откуда затем выбираются строки для
обработки.

Пример:

```
mysql> select concat(cust.last_name, ' ', cust.first_name) Concatination
from 
(
  select first_name, last_name
  from customer
  where first_name = 'JESSIE'
) cust;

+---------------+
| Concatination |
+---------------+
| BANKS JESSIE  |
| MILAM JESSIE  |
+---------------+
```

Разберемся с запросом по порядку:
1) Сперва выполняется подзапрос from: он формирует таблицу, состоящую из колонок
   first_name и last_name и фильтрует её с применением подзапроса where;
2) Получившейся таблице присваивается псевдоним cust и именно это имя таблицы
   указывается в функции concat;
3) Родительский запрос select выбирает функцию конкатенации для каждой из строк
   таблицы cust и возвращает результат.

### Временные таблицы.

Обычно, любая реляционная СУБД позволяет создать временную таблицу, такую, чьи
данные хранятся до окончания транзакции, либо до окончания сеанса работы (в СУБД
от Oracle временные таблицы не удаляются при завершении сеанса работы). В MySQL
такие таблицы создаются с применением ключевого слова **TEMPORARY** после
предложения select.

```
create temporary table dummy table
(
  int_value int
);
```

Причем запрос show talbes не будет возвращать временную таблицу.

### Представление.

Представление - это запрос, который хранится в словаре данных (Шо такое словарь
данных никто не объясняет, но зато книжки пишут). Создается следующей
конструкцией:
```
create view 'название_представления' as ... 
```
Определение представления не принуждает СУБД к созданию новых данных. По своей
сути представление хранит лишь "фильтр". К которому в будущем можно будет
обратиться. Чтобы лучше освоиться с применением представлений, создадим таблицу,
в которую сложим 1 и 2, создадим представление, которое будет дергать из этой
таблицы те строки, в которых будет значение 2, а затем запросим все строки из представления:
```
create table t (value int);

insert t values (1), (2);

create view as my_view as (select * from t where value = 2);

select * from my_view;

+-------+
| value |
+-------+
|     2 |
+-------+
```

Механизм работы похож на временные таблицы, но применение представлений не
побуждает к использовнию дополнительной памяти (сделаем поблажку и не будем
считать те пару килобайт, необходимых для запоминания СУБД представления, как
расходование памяти).

### Связи таблиц.

В определении from я упомянул, что from определяет средство связывания таблиц.
Дело в том, что стандарт ANSI требует указания условий связывания таблиц, если в
запросе используется несколько таблиц (всяческие join'ы).

Можно перечислить таблицы через запятую в подзапросе from, MySQL неявно проведет
их объединение по принципам, с которыми я еще не знаком.

### Псевдонимы таблиц.

Когда происходит объединение таблиц в предложении from, необходим способ
различить, к какому столбцу происходит обращение. Сделать это можно двумя
путями:
- использовать полное имя 'имя_таблицы.имя_столбца';
- повесить таблице псевдоним, чтобы точно также использовать полное имя.

##### Как назначить таблице или столбцам псевдонимы?

Чтобы в запросе select переименовать таблицу достаточно следующей конструкции:

```
select * from table1 renamed_table;
```

Таким образом таблица была переименована в renamed_table.

А чтобы переименовать столбцы следует использовать следующую конструкцию:

```
select renamed_table.column1, renamed_table.column2 from table1 renamed_table;
```

Задача: Как навесить псевдоним двум стобцам из одной таблицы и двум столбцам из другой таблицы в запросе к двум таблицам сразу?

```
mysql> select table1.value 'value from table1' from test_table table1, test_table_2 table2;
+-------------------+
| value from table1 |
+-------------------+
|                 1 |
|                 2 |
+-------------------+

mysql> select table1.value 'value from table1', table2.value 'value from table2', table1.description, table2.description from test_table table1, test_table_2 table2;
+-------------------+-------------------+--------------+------------------+
| value from table1 | value from table2 | description  | description      |
+-------------------+-------------------+--------------+------------------+
|                 1 |                 4 | text         | это из таблицы 2 |
|                 2 |                 4 | another_text | это из таблицы 2 |
+-------------------+-------------------+--------------+------------------+
```

Вот таким образом. Достаточно лишь навесить псевдонимы таблицам, а затем
обратиться к столбцам по новым псевдонимам, после чего необходимо навесить
псевдонимы уже столбцам.

Задача: можно ли использовать ключевое слово AS при применении псевдонимов к таблицам?

Да, вполне. Достаточно после имени таблицы использовать ключевое слово и затем
указать псевдоним.

```
select * from table1 as t;
```

### Предложение where.
Задача: зачем нужно предложение where?

Применение where позволяет выделить необходимые данные из исходных при помощи
логических выражений. Таким образом предложение where выступает в роли фильтра.

##### Как применить where?
Задача: Пусть, имеется таблица. В таблице одна колонка value с типом int. В таблице две
записи, в одной в столбце value число меньшее 5, а в другой число равное 5. Как
запросить отдельно то и другое?

```
mysql> select * from table1 where value < 5;
+-------+
| value |
+-------+
|     1 |
+-------+

mysql> select * from table1 where value = 5;
+-------+
| value |
+-------+
|     5 |
+-------+
```

Задача: Как написать в этом же случае запрос с where, состоящий из логического
выражения, но такой, который вернет обе строки?

```
select * from table1 where value < 3 or value > 3;
+-------+
| value |
+-------+
|     1 |
|     5 |
+-------+
```

### Предложения group by и having.

Group by призван групировать. Группирует он интересным образом: допустим, в
таблица примерно такого вида:

```
+------+--------+------+--------+
| id   | name   | age  | salary |
+------+--------+------+--------+
|    1 | Дима   |   23 |    100 |
|    2 | Петя   |   23 |    200 |
|    3 | Вася   |   23 |    300 |
|    4 | Коля   |   24 |   1000 |
|    5 | Иван   |   24 |   2000 |
|    6 | Кирилл |   25 |   1000 |
+------+--------+------+--------+
```

Первым делом необходимо определиться с тем, а по какому критерию мы хотим
группировать. По этому критерию каждая группа будет считаться уникальной.
Например, можно группировать по имени, в таком случае у нас появится 6 групп,
ведь имена уникальны в таблице:

```
mysql> select name from workers group by name;
+--------+
| name   |
+--------+
| Дима   |
| Петя   |
| Вася   |
| Коля   |
| Иван   |
| Кирилл |
+--------+
```

А можно группировать по возрасту и в этом случае у нас уже начинает появляться
что- то интересное, ведь уникальных значений возраста меньше, нежели строк в
таблице, а именно, всего 3 (23, 24, 25):

```
mysql> select age from workers group by age;
+------+
| age  |
+------+
|   23 |
|   24 |
|   25 |
+------+
```

Отлично, получилось. Далее возникает интерес воспользоваться новоизученным
инструментом. На данный момент мне необходимо знать о том, что только одна
колонка может фигурировать в предложении group by, все остальные колонки должны
быть аггрегированы (аггрегация означает объединение. Поэтому агрегатные функции
носят такое название, посколько объединяют множественные значения в одно)

Путем достижения этой цели должно стать использование агрегатной функции, к
примеру, суммирование зарплат. Возможно узнать, какова средняя зарплата по
возрасту:

```
mysql> select age, sum(salary) from workers group by age;
+------+-------------+
| age  | sum(salary) |
+------+-------------+
|   23 |         600 |
|   24 |        3000 |
|   25 |        1000 |
+------+-------------+
```

Аналогично можно посчитать среднюю зарплату по возрасту:

```
mysql> select age, round(avg(salary),0) from workers group by age;
+------+----------------------+
| age  | round(avg(salary),0) |
+------+----------------------+
|   23 |                  200 |
|   24 |                 1500 |
|   25 |                 1000 |
+------+----------------------+
```

Задача: как вызвать функцию подсчета суммы элементов, функцию вычисления
среднего значения, функцию округления до 0 знаков после запятой и до 2 знаков
после запятой?

Получается, что применение group by формирует из первоначальных данных (одной
или нескольких объединенных таблиц) "подтаблички по- меньше", после этого СУБД
ожидает встретить функцию агрегации, чтобы упаковать множественные значения из
"подтабличек" в одно значение для каждой одной группы.

### Подробнее про having.

having используется для фильтрации результатов группировки. Пусть, есть желание
запросить только те возраста, средняя зарплата которых меньше 1000 у.е. Сделать
это можно следующим образом:

```
mysql> select age, round(avg(salary)) from workers group by age having round(avg(salary)) < 1000;
+------+--------------------+
| age  | round(avg(salary)) |
+------+--------------------+
|   23 |                200 |
+------+--------------------+
```

Having распознает и более сложные логические выражения с применением
конъюнкции, дизъюнкции и других.

### Предложение order by.

Полагаться на порядок следования строк в выводе СУБД не стоит. Его следует
считать случайным, хоть и в некоторых СУБД указывается ключ сортировки, по
которому можно предположить тот порядок, в котором СУБД выплюнет элементы.

Для сортировки тех данных, которые уже вот- вот готовы показаться пользователю
используется order by.

Синтаксис прост: необходимо написать order by в конце SQL- запроса, а после него
указать столбец, по которому будет происходить сортировка. В дополнение к этому
можно указать ключевое слово **desc**, что значит descending, то есть по-
убыванию, для сортировки по возрастанию возможно применить ключевое слово
**asc**, то есть ascending.

Если указать несколько столбцов в запросе, СУБД будет сортировать по первому
указанному, при обнаружении одинаковых значений в этом столбце, СУБД произведет
сортировку этих значений основываясь уже на значениях из второго столбца.

Задача: Как сортировать по указанному порядковому номеру столбца, а не по его
названию?

Для этого достаточно всего лишь указать число после оператора order by. Столбцы
нумеруются начиная с 1. В представленом далее запросе происходит сортировка по
второму столбцу:

```
mysql> select * from table1 order by 2;
```

Также можно через запятую указать несколько столбцов по их порядковым номерам:

```
mysql> select * from table1 order by 1, 2;
```

## Фильтрация.

Все инструкции SQL за исключением insert позволяют использование предложения
where.

Задача: как выглядит оператор "не равно" в MySQL?
Либо <>, либо !=.

Условие, применяемое с where состоит из операторов и операндов. Операнды могут
быть такими:
- числа;
- столбца таблицы или представления;
- строкового литерала;
- встроенной фунции, к примеру sum, concat или другой;
- подзапроса;
- списка выражений, к примеру ('value1', 'value2').

Операторы представлены следующими штуками- дрюками:
- Операторы сравнения: =, !=, <, >, <>, like, in и between;
- Арифметические операторы: +, -, *, /.

Задача: зачем нужен оператор between?

Оператор between является синтаксическим сахаром и позволяет упаковывать двойное
неравенство в более читаемый человеком вид. Следующие запросы идентичны:

```
mysql> select * from table1 where value1 <= 3 and value1 >= 1;

mysql> select * from table1 where value1 between 1 and 3;
```

### Условие членства.
Условие членства достигается путем использования оператора in. Как, к примеру, в
примере далее:

```
mysql> select * from table1 where value2 in (2, 3);
```

### Подзапросы.
При использовании диапазона не обязательно вручную перечислять чреез запятую все
возможные значения, вместо этого можно написать запрос, возвращающий одну
колонку, значения которой будут выступать диапазоном для in.

```
mysql> select value from table1 where value in (select value from table2);
```

### Условия соответствия.
Условия соответствия отличаются от рассмотренных ранее условий тем, что не
действуют в таком строгом виде. Эта концепция мне понятна, так что можно
обойтись рассмотрением полезных встроенных функций:

#### Функция left(колонка, число символов).
Функция left отрезает от значения из строки в колонке число указанных символов и
возвращает в качестве результата

#### Оператор LIKE.
Использование оператора like похоже на использование регулярных выражений.
Оператор like используется совместно с шаблоном, в котором понатыканы символы
подстановки. Синтаксис таков:

```
mysql> select some_text from table1 where some_text like '_A_T%S';
```

В примере выше шаблон '_A_T%S' может быть рассмотрен как "Первый символ строки
может быть любым, на втором месте символ A, на третьем месте опять любой символ,
после чего должен следовать символ T на четвертом месте, затем любые символы в
любом количестве вполь до момента, когда будет встречен символ S, на котором
строка и должна закончиться."

Задача: какие три типа символов подстановки бывают?
* _ - любой одиночный символ;
* % - любое число любых символов;
* A - конкретный символ.

#### Регулярные выражения.
Регулярные выражения применяются таким образом:

```
select value from table1 where value regexp '^[QY]';
```

Собственно говоря, обычные регулярки. Изучив их синтаксис однажды- использовать
возможно везде.

### NUll.
Null в SQL несет такой же смысл, как и во всех остальных известных мне местах.
Но существует исключение: **С Null нельзя сравнивать**. То есть выражение value
!= NULL некорректно. Вместо этого с null необходимо использовать операторы
**is** и **not**.

## Запросы к нескольким таблицам.

Таблицы через join можно объединять различными способами. Одии из них является
Декартово произведение.

### Декартово произведение. Перекрестное соедниение.

```
mysql> select c.first_name, a.address from customer c join address a;
```

Этот запрос выведет порядка 360000 записей, при этом в таблицах customer и
address всего около 600 записей. А откуда же взялись 360000? Прсто СУБД
предложила все возможные сочетания людей и адресов, перемножив 600 на 600 и
получив 360000 возможных вариантов.

### Внутренее соединение.

Возможно поменять предыдщуий запрос так, чтобы для каждого человека выводился
лишь его адрес. Для этого в таблице с людями присутствует колонка address_id,
она является внешним ключом для таблицы address. В таблице adress также есть
колонка address_id, являющаяся первичным ключом этой таблицы.

Чтобы решить поставленную задачу следует придерживаться такой логики:
"Многоуважаемая СУБД, пожалуйста, обрати внимание на поле address_id в таблице
customer, пройди по связи и посмотри в таблице поле address, соответствующее
этому address_id".

Реализация этой логики такова:

```
mysql> select c.first_name, a.address from customer c join address a on c.address_id = a.address_id;
```

Если в одной из таблиц присутствует значение address_id, а в другой нет- то
такая строка исключается из результирующего набора. (Чтобы не исключать строки с
отсутствующими значениями применяется внешнее соединение.)

**В продемонстрированном выше запросе применялось именно внутреннее соединение,
просто неявно.**

А вот так выглядит его явная форма:

```
mysql> select c.first_name, a.address from customer c inner join address a on c.address_id = a.address_id;
```

Задача: как можно исключить использование ключевого слова on при внутреннем
объединении?

Если столбцы, по которым производится объединение, имеют одинаковое название,
можно сделать финт ушами: использовать ключевое слово using:

```
mysql> select c.first_name, a.address from customer c inner join address a using (address_id);
```

Правда в таком случае стоит использовать скобки -_-

### Синтаксис соединения ANSI.

Синтаксис ANSI является более старым по сравнению с используемым SQL92. Все
популярные СУБД поддерживают оба синтаксиса, в принципе, синтаксис ANSI может
быть удобен в некоторых случаях. На этом синтаксисе внутреннее объединение
таблиц будет выглядеть следующим образом:

```
mysql> select c.first_name, a.address from customer c, address a where c.address_id = a.address_id;
```

Алан Болье отмечает, что новый синтаксис SQL92 имеет преимущество в
переносимости между серверами, в то время как старый ANSI могут не поддерживать
СУБД, разработанные после 1992 года. Также синтаксис SQL92 выигрывает в условиях
сложных запросах:

SQL92
```
mysql> select c.first_name, c.last_name, a.address from customer c inner join address a using (address_id) where a.postal_code = 52137;
```

ANSI
```
mysql> select c.first_name, c.last_name, a.address from customer c, address a where c.address_id = a.address_id and a.postal_code = 52137;
```

Этот пример приводит автор книги и утверждает, что синтаксис SQL92 выглядит
проще, потому что проще увидеть условия объединения, а также наглядно показано,
какой вид объединения используется. На мой взгляд, это не показательный пример.

### Соединение трех и более таблиц.

Для соединения трех и более таблиц необходимо "пристыковать одну к другой и одну
к другой и так далее.

таблица1 inner join таблица2 using() inner join таблица3 using()

```
mysql> select c.first_name, ct.city from customer c inner join address using (address_id) inner join city ct using (city_id);
```

Задача: влияет ли порядок перечисления таблиц в from на результат?

Не влияет. SQL является декларативным языком, так что нет никакой разницы, в
каком порядке были перечислены таблицы. СУБД самостоятельно позаботится об
объединении. Но существует механимзм, позволяющий строго указать порядок, в
котором следует присовывать одну таблицу к другой. Для этого следует
использовать ключевое слово straight_join в MySQL, force order в SQL Server или
другой подобный механизм в других СУБД.

### Использоание подзапросов в качестве таблиц.

А вот, собственно говоря, что тут имеется ввиду:
В предыдущем параграфе мы использовали связь между таблицами customer и address
через address_id, а также связь между address и city через city_id.

Можно сделать по другому. Через подзапрос можно сформировать таблицу, которая
содержит address_id и city. А вот уже и появляется возможность связать customer
и city через address_id.

Вот пример реализации:

```
mysql> select c.first_name, ct.city from customer c inner join (select address.address_id, city.city from address inner join city using (city_id)) ct using (address_id);
```
