# MySQL "Изучаем SQL" Алан Болье

## Лайфхаки и тонкости
Большинство реализаций SQL воспринимают /* ... */ как комментарий
***

Некоторые СУБД обязывают в запросе к себе указывать FROM и название таблицы.
Например СУБД Oracle. Для того, чтобы только вызвать встроенную функцию, Oracle
предоставляет таблицу dual с единственной строкой данных. Поэтому вызов функции
now() в Oracle Database выглядит следующим образом:
```
SELECT now() FROM dual;
```
***
При хранении строк возникают закономерные проблемы: строковые символы, иногда
даже одинакового значения, будут представлены в памяти во- первых по разному, а
во- вторых скорее всего с разным объемом занимаемой памяти. Виной всему в этом
несовершенном виде кодировки (сами по себе они то не виноваты, а скорее даже
полезны. Просто попали под горячую руку). Так вот, чтобы узнать, какие кодировки
доступны в MySQL необходимо ввести следующую инструкцию: 

```
SHOW CHARACTER SET;
mysql> SHOW CHARACTER SET;
+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |

```
***

При сортировке или группировке текстовых данных в MySQL используются только
первые 1024 байта. Это значение может быть увеличено.

## Типы данных

### Символьные данные

Символьные данные хрянятся в виде строк фиксированной или переменной длины.
Отличие строк с фиксированной длинной заключается в том, что они справа
дополняются пробелами, а также всегда занимают одно и то же число байт.

Задать ограничение на длину можно следующим образом:

```
char(20) /*Фиксированная длина */
varchar(20) /*Пременная длина*/
```

В MySQL существуют ограничения: char ограничен 255 байтами, а varchar 65535 байтами.

Чтобы указать кодировку, в которой хранится текст, при задании типа столбца необходимо её указать:

```
varchar(20) character set latin1
```

А также можно задать значение кодировки по- умолчанию для всей БД:

```
CREATE DATABASE DB1 CHARACTER SET latin1;
```

Текстовые данные. Данный тип данных позволяет обойти ограничение в 64 КБайт на размер текста. Подразделяется на:
- tinytext	255 Байт;
- text		65 535 Байт
- mediumtext	16 777 215 Байт;
- longtext	4 294 967 295 Байт.

После того, как varchar стал поддерживать до 64 КБайт текстовых данных, смысл в использовании tinytext и text отпал.

### Числовые типы данных

### Целые числа

- tinyint (от -128 до 127), а беззнаковый вариант от 0 до 255
- smallint (от -32 768 до 32 767), а беззнаковый вариант от 0 до 65 535
- mediumint (от -8 388 608 до 8 388 607), а беззнаковый вариант от 0 до 16 777 215
- int (от -2 147 483 648 до 2 147 483 647), а беззнаковый вариант от 0 до 4 294 967 295
- bigint (от -2^63 до 2^63 - 1), а беззнаковый вариант от 0 до 2^64 - 1
Числа с плавающей точкой:
- float (p, s) тут какие- то уж адские диапазоны
- double (p, s)

При указании типа с плавающей точкой можно указать его точность (p - precision).
Это общее число цифр слева и справа от точки. Также можно указать масштаб (s -
scale). Это уже число цифр справа от точки.

### Данные типа времядата (временнОй тип)
- date		YYYY-MM-DD от 1000-01-01 до 9999-12-31
- datetime	YYYY-MM-DD HH:MI:SS от 1000-01-01 00:00:00.000000 до 9999-12-31 23:59:59.999999
- timestamp 	YYYY-MM-DD HH:MI:SS от 1970-01-01 00:00:00.000000 до 2038-01-18 22:14:07.999999
- year		YYYY от 1901 до 2155
- time		HHH:MI:SSS от -838:59:59.000000 до 838:59:59.000000

СУБД берет на себя задачу по представлению входных данных в виде внутренней
реализации. Условием лишь является подача на вход строковых данных в требуемом
формате. Например для колонки с типом date подойдет такая строка: "2022-01-27"
Типы datetime и timestamp позволяют включать в себя миллионные доли секунды. Для
этого при задании таблицы необходимо указать в скобках трубуемую точность:
datetime (2).

## Создание базы данных

База создается через конструкцию CREATE DATABASE;

Чтобы переключить контекст на необходимую базу и не вводить её название при
каждом обращении к таблицам внутри, используется конструкция USE 'название_
базы'

## Создание таблицы

Таблица создается конструкцией CREATE TABLE ();

### Первичный ключ
Первичный ключ используется для однозначной идетификации записи в таблице.
Первичный ключ должен быть уникальным, не может быть Nullable, а также  в одной
таблице может быть только один первичный ключ.

Первичный ключ можно задать при создании базы, описав его словно колонку:
PRIMARY KEY ('название_колонки' или 'описание_составного_ключа')

Также первичный ключ можно указать уже после создания таблицы через ALTER TABLE:
ALTER TABLE 'название_таблицы' ADD PRIMARY KEY ('название_колонки' или
'описание_составного_ключа')

MySQL позволяет в качестве первичного ключа использовать как и одну из
пользовательских колонок (что далеко не является оптимальным решением), так и
оставить эту задачу на разрешение движком СУБД. Во втором случае предлагается
припихнуть к числовому полю AUTO_INCREMENT

```
CREATE TABLE auto_increment_showing_table 
(
    person_id SMALLINT UNSIGNED AUTO_INCREMENT,
    name VARCHAR(30),
    PRIMARY KEY (person_id)
);
```

### Внешний ключ
Внешний ключ используется для связи в базовом случае двух таблиц. Например,
существует таблица, хранящая в себе логи. В этой таблице представлены числовые
значения severity и facility. Чтобы иметь возможность транлировать их в
строковые представления создадим две дополнительные таблицы. В одной табличке
будут храниться сопоставления severity, а в другой facility.

***
## Запрос SELECT
При выполнении запроса сервер возвращает **результирующий набор**, а точнее, еще
одну таблицу.

Запрос SELECT состоит из следующих составных частей:
- select определяет, какие столбцы следует включить в результирующий набор;
- from определяет таблицы, из которых следует выбирать данные, а также те
  таблицы, которые должны быть соединены;
- where отсеивает ненужные данные;
- group by используется для группировки строк по общим значениям столбцов;
- having отсеивает ненужные данные;
- order by упорядочивает строки в результирующем наборе по одному или нескольким
  столбцам.

Предложение select, помимо выбора тех столбцов, которые необходимо запросить,
позволяет включать также:
- числовые или строковые литералы;
- выражения;
- результаты работы вызова встроенных функций;
- результаты работы вызова пользовательских функций.

```
mysql> select language_id,
    'COMMON' lancuage_usage,
    language_id * 3.1415 lang_pi_value,
    upper(name) UpperName
from language;
+-------------+----------------+---------------+-----------+
| language_id | lancuage_usage | lang_pi_value | UpperName |
+-------------+----------------+---------------+-----------+
|           1 | COMMON         |        3.1415 | ENGLISH   |
|           2 | COMMON         |        6.2830 | ITALIAN   |
|           3 | COMMON         |        9.4245 | JAPANESE  |
|           4 | COMMON         |       12.5660 | MANDARIN  |
|           5 | COMMON         |       15.7075 | FRENCH    |
|           6 | COMMON         |       18.8490 | GERMAN    |
+-------------+----------------+---------------+-----------+
6 rows in set (0.00 sec)
```
Таким образом применение select расширяется, позволяя на лету изменять имена
колонок:
```
mysql> select 'bla-bla' bla_bla_column from user_table_1;
+----------------+
| bla_bla_column |
+----------------+
| bla-bla        |
+----------------+
1 row in set (0.00 sec)
```
А общий синтаксис выглядит как "select (значение из колонки/ результат
выражения/ литерал) (название колонки, куда это будет запихнуто) из таблицы
(название таблицы)"

Помимо этого интересно и то, что from является хоть и немаловажной, но вовсе не
обязательной частью запроса SELECT. К примеру, можно запросить вызов встроенных
функций, а в этом случае отпадает необходимость в выборке столбцов из какой-
либо таблицы:
```
mysql> select now(), version(), database();
+---------------------+-----------+------------+
| now()               | version() | database() |
+---------------------+-----------+------------+
| 2023-02-19 00:15:59 | 8.0.32    | sakila     |
+---------------------+-----------+------------+
1 row in set (0.02 sec)
```