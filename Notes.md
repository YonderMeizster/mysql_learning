# MySQL "Изучаем SQL". Автор книги: Алан Болье.

## Лайфхаки и тонкости.
Большинство реализаций SQL воспринимают /* ... */ как комментарий

Некоторые СУБД обязывают в запросе к себе указывать FROM и название таблицы.
Например СУБД Oracle. Для того, чтобы только вызвать встроенную функцию, Oracle
предоставляет таблицу dual с единственной строкой данных. Поэтому вызов функции
now() в Oracle Database выглядит следующим образом:

```
SELECT now() FROM dual;
```

При хранении строк возникают закономерные проблемы: строковые символы, иногда
даже одинакового значения, будут представлены в памяти во- первых по разному, а
во- вторых скорее всего с разным объемом занимаемой памяти. Виной всему в этом
несовершенном виде кодировки (сами по себе они то не виноваты, а скорее даже
полезны. Просто попали под горячую руку). Так вот, чтобы узнать, какие кодировки
доступны в MySQL необходимо ввести следующую инструкцию: 

```
SHOW CHARACTER SET;
mysql> SHOW CHARACTER SET;
+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |
```

При сортировке или группировке текстовых данных в MySQL используются только
первые 1024 байта. Это значение может быть увеличено.

## Типы данных.

### Символьные данные.

Символьные данные хрянятся в виде строк фиксированной или переменной длины.
Отличие строк с фиксированной длинной заключается в том, что они справа
дополняются пробелами, а также всегда занимают одно и то же число байт.

Задать ограничение на длину можно следующим образом:

```
char(20) /*Фиксированная длина */
varchar(20) /*Пременная длина*/
```

В MySQL существуют ограничения: char ограничен 255 байтами, а varchar 65535 байтами.

Чтобы указать кодировку, в которой хранится текст, при задании типа столбца необходимо её указать:

```
varchar(20) character set latin1
```

А также можно задать значение кодировки по- умолчанию для всей БД:

```
CREATE DATABASE DB1 CHARACTER SET latin1;
```

Текстовые данные. Данный тип данных позволяет обойти ограничение в 64 КБайт на размер текста. Подразделяется на:
- tinytext	255 Байт;
- text		65 535 Байт
- mediumtext	16 777 215 Байт;
- longtext	4 294 967 295 Байт.

После того, как varchar стал поддерживать до 64 КБайт текстовых данных, смысл в использовании tinytext и text отпал.

### Числовые типы данных.

#### Целые числа.

- tinyint (от -128 до 127), а беззнаковый вариант от 0 до 255
- smallint (от -32 768 до 32 767), а беззнаковый вариант от 0 до 65 535
- mediumint (от -8 388 608 до 8 388 607), а беззнаковый вариант от 0 до 16 777 215
- int (от -2 147 483 648 до 2 147 483 647), а беззнаковый вариант от 0 до 4 294 967 295
- bigint (от -2^63 до 2^63 - 1), а беззнаковый вариант от 0 до 2^64 - 1
Числа с плавающей точкой:
- float (p, s) тут какие- то уж адские диапазоны
- double (p, s)

При указании типа с плавающей точкой можно указать его точность (p - precision).
Это общее число цифр слева и справа от точки. Также можно указать масштаб (s -
scale). Это уже число цифр справа от точки.

#### Данные типа времядата (временнОй тип).
- date		YYYY-MM-DD от 1000-01-01 до 9999-12-31
- datetime	YYYY-MM-DD HH:MI:SS от 1000-01-01 00:00:00.000000 до 9999-12-31 23:59:59.999999
- timestamp 	YYYY-MM-DD HH:MI:SS от 1970-01-01 00:00:00.000000 до 2038-01-18 22:14:07.999999
- year		YYYY от 1901 до 2155
- time		HHH:MI:SSS от -838:59:59.000000 до 838:59:59.000000

СУБД берет на себя задачу по представлению входных данных в виде внутренней
реализации. Условием лишь является подача на вход строковых данных в требуемом
формате. Например для колонки с типом date подойдет такая строка: "2022-01-27"
Типы datetime и timestamp позволяют включать в себя миллионные доли секунды. Для
этого при задании таблицы необходимо указать в скобках трубуемую точность:
datetime (2).

## Создание базы данных.

База создается через конструкцию CREATE DATABASE;

Чтобы переключить контекст на необходимую базу и не вводить её название при
каждом обращении к таблицам внутри, используется конструкция USE 'название_
базы'

## Создание таблицы.

Таблица создается конструкцией CREATE TABLE ();

### Первичный ключ.
Первичный ключ используется для однозначной идетификации записи в таблице.
Первичный ключ должен быть уникальным, не может быть Nullable, а также  в одной
таблице может быть только один первичный ключ.

Первичный ключ можно задать при создании базы, описав его словно колонку:
PRIMARY KEY ('название_колонки' или 'описание_составного_ключа')

Также первичный ключ можно указать уже после создания таблицы через ALTER TABLE:
ALTER TABLE 'название_таблицы' ADD PRIMARY KEY ('название_колонки' или
'описание_составного_ключа')

MySQL позволяет в качестве первичного ключа использовать как и одну из
пользовательских колонок (что далеко не является оптимальным решением), так и
оставить эту задачу на разрешение движком СУБД. Во втором случае предлагается
припихнуть к числовому полю AUTO_INCREMENT

```
CREATE TABLE auto_increment_showing_table 
(
    person_id SMALLINT UNSIGNED AUTO_INCREMENT,
    name VARCHAR(30),
    PRIMARY KEY (person_id)
);
```

### Внешний ключ.
Внешний ключ используется для связи в базовом случае двух таблиц. Например,
существует таблица, хранящая в себе логи. В этой таблице представлены числовые
значения severity и facility. Чтобы иметь возможность транлировать их в
строковые представления создадим две дополнительные таблицы. В одной табличке
будут храниться сопоставления severity, а в другой facility.

```
mysql> create table table_foreig
(
  actor_id int unsigned,
  film varchar(30),
  constraint pk primary key (actor_id, film),
  constraint fk foreign key (actor_id) references table_prim(id));

Query OK, 0 rows affected (0.01 sec)
```

Чтобы задать внешний ключ необходимо создать колонку с такими же параметрами,
как и колонка, на которую этот ключ будет вести. Имеется ввиду тип данных,
ограничение на размер и так далее. После этого при создании новой таблицы
необходимо создать ограничение с помощью ключевого слова **CONSTRAINT**,
обозвать его как- нибудь, к примеру **fk**, что означает foreign key. А уже для
этого ограничения описать внешний ключ. Синтаксис достаточно прост: foreign key
(название_столбца_в_новой_таблице) references другая_таблица(колонка).

> Есть у меня подозрения, что функционал механизма ограничений не заканчивается
> лишь возможностью их создавать. Возможно, в качестве внешнего ключа можно
> применять именованые ограничения первичного ключа, но пока что этот момент не прояснен.

## Запрос SELECT.
При выполнении запроса сервер возвращает **результирующий набор**, а точнее, еще
одну таблицу.

Запрос SELECT состоит из следующих составных частей:
- select определяет, какие столбцы следует включить в результирующий набор;
- from определяет таблицы, из которых следует выбирать данные, а также те
  таблицы, которые должны быть соединены;
- where отсеивает ненужные данные;
- group by используется для группировки строк по общим значениям столбцов;
- having отсеивает ненужные данные;
- order by упорядочивает строки в результирующем наборе по одному или нескольким
  столбцам.

Предложение select, помимо выбора тех столбцов, которые необходимо запросить,
позволяет включать также:
- числовые или строковые литералы;
- выражения (к примеру математические);
- результаты работы вызова встроенных функций;
- результаты работы вызова пользовательских функций.

```
mysql> select language_id,
    'COMMON' language_usage,
    language_id * 3.1415 lang_pi_value,
    upper(name) UpperName
from language;
+-------------+----------------+---------------+-----------+
| language_id | lancuage_usage | lang_pi_value | UpperName |
+-------------+----------------+---------------+-----------+
|           1 | COMMON         |        3.1415 | ENGLISH   |
|           2 | COMMON         |        6.2830 | ITALIAN   |
|           3 | COMMON         |        9.4245 | JAPANESE  |
|           4 | COMMON         |       12.5660 | MANDARIN  |
|           5 | COMMON         |       15.7075 | FRENCH    |
|           6 | COMMON         |       18.8490 | GERMAN    |
+-------------+----------------+---------------+-----------+
```

Таким образом применение select расширяется, позволяя на лету изменять имена
колонок:

```
mysql> select 'bla-bla' bla_bla_column from user_table_1;
+----------------+
| bla_bla_column |
+----------------+
| bla-bla        |
+----------------+
```

А общий синтаксис выглядит как "select (значение из колонки/ результат
выражения/ литерал) (название колонки, куда это будет запихнуто) из таблицы
(название таблицы)"

> Чтобы подчеркнуть изменение имени колонки можно использовать ключевое слово **as**
> между запрашиваемым значением колонки и псевдонимом:

>```
>mysql> select now() as 'Время сейчас';
>+---------------------+
>| Время сейчас        |
>+---------------------+
>| 2023-02-25 02:09:41 |
>+---------------------+
>```


Помимо этого интересно и то, что from является хоть и немаловажной, но вовсе не
обязательной частью запроса SELECT. К примеру, можно запросить вызов встроенных
функций, а в этом случае отпадает необходимость в выборке столбцов из какой-
либо таблицы:

```
mysql> select now(), version(), database();
+---------------------+-----------+------------+
| now()               | version() | database() |
+---------------------+-----------+------------+
| 2023-02-19 00:15:59 | 8.0.32    | sakila     |
+---------------------+-----------+------------+
```

### Удаление дубликатов.

Чтобы избавиться от дубликатов достаточно добавить ключевое слово **distinct**
после предложения **select**:

```
mysql> select * from t1;
+------+
| col1 |
+------+
|    1 |
|    2 |
|    3 |
|    1 |
|    1 |
|    1 |
+------+

mysql> select distinct * from t1;
+------+
| col1 |
+------+
|    1 |
|    2 |
|    3 |
+------+
```

**На самом деле неявно к запросам select пристыковывается ключевое слово all, если**
**не указано другого, например distinct.**

Употребление distinct может заметно негативно повлиять на скорость выполнения
запроса к большому количеству данных по причине того, что оптимизатор выполнит
сортировку, а то и несколько.

### Предложение from.

*Предложение from определяет таблицы, используемые запросом, наряду со
средствами связывания таблиц вместе.*

### Таблицы.

В общем- то неверно думать о таблицах только как о строках, связанных воедино и
хранящихся в базе данных. Это неверно по причине того, что таблиц существует
несколько видов:

- Постоянные таблицы. Они создаются при помощи инструкции CREATE TABLE;
- Произвольные таблицы. Совокупность строк, возвращаемых подзапросами (WHERE,
  HAVING, FROM и так далее). Хранятся исключительно во временной памяти
  вычислительной машины;
- Временные таблицы. Изменяемые данные, хранящиеся в памяти. По сути,
  представляют собой такие же таблицы, но существуют лишь на протяжении времени
  сессии подключения к СУБД;
- Виртуальные таблицы. Создаются с помощью инструкции CREATE VIEW.

И объединяет это все многообразие то, что их можно запихнуть в предложение from.

### Производные таблицы. Таблицы, генерируемые подзапросами.

Подзапрос- запрос, содержащийся в другом запросе. Подзапросы могут быть окружены
скобками. В запросе select подзапросы могут быть встроены во многие места, но в
контексте использования from подзапрос определяет произвольную таблицу, которая
видна из всех других мест запроса.

Иными словами from создает временную таблицу, откуда затем выбираются строки для
обработки.

Пример:

```
mysql> select concat(cust.last_name, ' ', cust.first_name) Concatination
from 
(
  select first_name, last_name
  from customer
  where first_name = 'JESSIE'
) cust;

+---------------+
| Concatination |
+---------------+
| BANKS JESSIE  |
| MILAM JESSIE  |
+---------------+
```

Разберемся с запросом по порядку:
1) Сперва выполняется подзапрос from: он формирует таблицу, состоящую из колонок
   first_name и last_name и фильтрует её с применением подзапроса where;
2) Получившейся таблице присваивается псевдоним cust и именно это имя таблицы
   указывается в функции concat;
3) Родительский запрос select выбирает функцию конкатенации для каждой из строк
   таблицы cust и возвращает результат.

### Временные таблицы.

Обычно, любая реляционная СУБД позволяет создать временную таблицу, такую, чьи
данные хранятся до окончания транзакции, либо до окончания сеанса работы (в СУБД
от Oracle временные таблицы не удаляются при завершении сеанса работы). В MySQL
такие таблицы создаются с применением ключевого слова **TEMPORARY** после
предложения select.

```
create temporary table dummy table
(
  int_value int
);
```

Причем запрос show talbes не будет возвращать временную таблицу.

### Представление.

Представление - это запрос, который хранится в словаре данных (Шо такое словарь
данных никто не объясняет, но зато книжки пишут). Создается следующей
конструкцией:
```
create view 'название_представления' as ... 
```
Определение представления не принуждает СУБД к созданию новых данных. По своей
сути представление хранит лишь "фильтр". К которому в будущем можно будет
обратиться. Чтобы лучше освоиться с применением представлений, создадим таблицу,
в которую сложим 1 и 2, создадим представление, которое будет дергать из этой
таблицы те строки, в которых будет значение 2, а затем запросим все строки из представления:
```
create table t (value int);

insert t values (1), (2);

create view as my_view as (select * from t where value = 2);

select * from my_view;

+-------+
| value |
+-------+
|     2 |
+-------+
```

Механизм работы похож на временные таблицы, но применение представлений не
побуждает к использовнию дополнительной памяти (сделаем поблажку и не будем
считать те пару килобайт, необходимых для запоминания СУБД представления, как
расходование памяти).

### Связи таблиц.

В определении from я упомянул, что from определяет средство связывания таблиц.
Дело в том, что стандарт ANSI требует указания условий связывания таблиц, если в
запросе используется несколько таблиц (всяческие join'ы).

Можно перечислить таблицы через запятую в подзапросе from, MySQL неявно проведет
их объединение по принципам, с которыми я еще не знаком.

### Псевдонимы таблиц.

Когда происходит объединение таблиц в предложении from, необходим способ
различить, к какому столбцу происходит обращение. Сделать это можно двумя
путями:
- использовать полное имя 'имя_таблицы.имя_столбца';
- повесить таблице псевдоним, чтобы точно также использовать полное имя.

##### Как назначить таблице или столбцам псевдонимы?

Чтобы в запросе select переименовать таблицу достаточно следующей конструкции:

```
select * from table1 renamed_table;
```

Таким образом таблица была переименована в renamed_table.

А чтобы переименовать столбцы следует использовать следующую конструкцию:

```
select renamed_table.column1, renamed_table.column2 from table1 renamed_table;
```

Задача: Как навесить псевдоним двум стобцам из одной таблицы и двум столбцам из другой таблицы в запросе к двум таблицам сразу?

```
mysql> select table1.value 'value from table1' from test_table table1, test_table_2 table2;
+-------------------+
| value from table1 |
+-------------------+
|                 1 |
|                 2 |
+-------------------+

mysql> select table1.value 'value from table1', table2.value 'value from table2', table1.description, table2.description from test_table table1, test_table_2 table2;
+-------------------+-------------------+--------------+------------------+
| value from table1 | value from table2 | description  | description      |
+-------------------+-------------------+--------------+------------------+
|                 1 |                 4 | text         | это из таблицы 2 |
|                 2 |                 4 | another_text | это из таблицы 2 |
+-------------------+-------------------+--------------+------------------+
```

Вот таким образом. Достаточно лишь навесить псевдонимы таблицам, а затем
обратиться к столбцам по новым псевдонимам, после чего необходимо навесить
псевдонимы уже столбцам.

Задача: можно ли использовать ключевое слово AS при применении псевдонимов к таблицам?

Да, вполне. Достаточно после имени таблицы использовать ключевое слово и затем
указать псевдоним.

```
select * from table1 as t;
```

### Предложение where.
Задача: зачем нужно предложение where?

Применение where позволяет выделить необходимые данные из исходных при помощи
логических выражений. Таким образом предложение where выступает в роли фильтра.

##### Как применить where?
Задача: Пусть, имеется таблица. В таблице одна колонка value с типом int. В таблице две
записи, в одной в столбце value число меньшее 5, а в другой число равное 5. Как
запросить отдельно то и другое?

```
mysql> select * from table1 where value < 5;
+-------+
| value |
+-------+
|     1 |
+-------+

mysql> select * from table1 where value = 5;
+-------+
| value |
+-------+
|     5 |
+-------+
```

Задача: Как написать в этом же случае запрос с where, состоящий из логического
выражения, но такой, который вернет обе строки?

```
select * from table1 where value < 3 or value > 3;
+-------+
| value |
+-------+
|     1 |
|     5 |
+-------+
```

### Предложения group by и having.

Group by призван групировать. Группирует он интересным образом: допустим, в
таблица примерно такого вида:

```
+------+--------+------+--------+
| id   | name   | age  | salary |
+------+--------+------+--------+
|    1 | Дима   |   23 |    100 |
|    2 | Петя   |   23 |    200 |
|    3 | Вася   |   23 |    300 |
|    4 | Коля   |   24 |   1000 |
|    5 | Иван   |   24 |   2000 |
|    6 | Кирилл |   25 |   1000 |
+------+--------+------+--------+
```

Первым делом необходимо определиться с тем, а по какому критерию мы хотим
группировать. По этому критерию каждая группа будет считаться уникальной.
Например, можно группировать по имени, в таком случае у нас появится 6 групп,
ведь имена уникальны в таблице:

```
mysql> select name from workers group by name;
+--------+
| name   |
+--------+
| Дима   |
| Петя   |
| Вася   |
| Коля   |
| Иван   |
| Кирилл |
+--------+
```

А можно группировать по возрасту и в этом случае у нас уже начинает появляться
что- то интересное, ведь уникальных значений возраста меньше, нежели строк в
таблице, а именно, всего 3 (23, 24, 25):

```
mysql> select age from workers group by age;
+------+
| age  |
+------+
|   23 |
|   24 |
|   25 |
+------+
```

Отлично, получилось. Далее возникает интерес воспользоваться новоизученным
инструментом. На данный момент мне необходимо знать о том, что только одна
колонка может фигурировать в предложении group by, все остальные колонки должны
быть аггрегированы (аггрегация означает объединение. Поэтому агрегатные функции
носят такое название, посколько объединяют множественные значения в одно)

Путем достижения этой цели должно стать использование агрегатной функции, к
примеру, суммирование зарплат. Возможно узнать, какова средняя зарплата по
возрасту:

```
mysql> select age, sum(salary) from workers group by age;
+------+-------------+
| age  | sum(salary) |
+------+-------------+
|   23 |         600 |
|   24 |        3000 |
|   25 |        1000 |
+------+-------------+
```

Аналогично можно посчитать среднюю зарплату по возрасту:

```
mysql> select age, round(avg(salary),0) from workers group by age;
+------+----------------------+
| age  | round(avg(salary),0) |
+------+----------------------+
|   23 |                  200 |
|   24 |                 1500 |
|   25 |                 1000 |
+------+----------------------+
```

Задача: как вызвать функцию подсчета суммы элементов, функцию вычисления
среднего значения, функцию округления до 0 знаков после запятой и до 2 знаков
после запятой?

Получается, что применение group by формирует из первоначальных данных (одной
или нескольких объединенных таблиц) "подтаблички по- меньше", после этого СУБД
ожидает встретить функцию агрегации, чтобы упаковать множественные значения из
"подтабличек" в одно значение для каждой одной группы.

### Подробнее про having.

having используется для фильтрации результатов группировки. Пусть, есть желание
запросить только те возраста, средняя зарплата которых меньше 1000 у.е. Сделать
это можно следующим образом:

```
mysql> select age, round(avg(salary)) from workers group by age having round(avg(salary)) < 1000;
+------+--------------------+
| age  | round(avg(salary)) |
+------+--------------------+
|   23 |                200 |
+------+--------------------+
```

Having распознает и более сложные логические выражения с применением
конъюнкции, дизъюнкции и других.

### Предложение order by.

Полагаться на порядок следования строк в выводе СУБД не стоит. Его следует
считать случайным, хоть и в некоторых СУБД указывается ключ сортировки, по
которому можно предположить тот порядок, в котором СУБД выплюнет элементы.

Для сортировки тех данных, которые уже вот- вот готовы показаться пользователю
используется order by.

Синтаксис прост: необходимо написать order by в конце SQL- запроса, а после него
указать столбец, по которому будет происходить сортировка. В дополнение к этому
можно указать ключевое слово **desc**, что значит descending, то есть по-
убыванию, для сортировки по возрастанию возможно применить ключевое слово
**asc**, то есть ascending.

Если указать несколько столбцов в запросе, СУБД будет сортировать по первому
указанному, при обнаружении одинаковых значений в этом столбце, СУБД произведет
сортировку этих значений основываясь уже на значениях из второго столбца.

Задача: Как сортировать по указанному порядковому номеру столбца, а не по его
названию?

Для этого достаточно всего лишь указать число после оператора order by. Столбцы
нумеруются начиная с 1. В представленом далее запросе происходит сортировка по
второму столбцу:

```
mysql> select * from table1 order by 2;
```

Также можно через запятую указать несколько столбцов по их порядковым номерам:

```
mysql> select * from table1 order by 1, 2;
```

## Фильтрация.

Все инструкции SQL за исключением insert позволяют использование предложения
where.

Задача: как выглядит оператор "не равно" в MySQL?
Либо <>, либо !=.

Условие, применяемое с where состоит из операторов и операндов. Операнды могут
быть такими:
- числа;
- столбца таблицы или представления;
- строкового литерала;
- встроенной фунции, к примеру sum, concat или другой;
- подзапроса;
- списка выражений, к примеру ('value1', 'value2').

Операторы представлены следующими штуками- дрюками:
- Операторы сравнения: =, !=, <, >, <>, like, in и between;
- Арифметические операторы: +, -, *, /.

Задача: зачем нужен оператор between?

Оператор between является синтаксическим сахаром и позволяет упаковывать двойное
неравенство в более читаемый человеком вид. Следующие запросы идентичны:

```
mysql> select * from table1 where value1 <= 3 and value1 >= 1;

mysql> select * from table1 where value1 between 1 and 3;
```

### Условие членства.
Условие членства достигается путем использования оператора in. Как, к примеру, в
примере далее:

```
mysql> select * from table1 where value2 in (2, 3);
```

### Подзапросы.
При использовании диапазона не обязательно вручную перечислять чреез запятую все
возможные значения, вместо этого можно написать запрос, возвращающий одну
колонку, значения которой будут выступать диапазоном для in.

```
mysql> select value from table1 where value in (select value from table2);
```

### Условия соответствия.
Условия соответствия отличаются от рассмотренных ранее условий тем, что не
действуют в таком строгом виде. Эта концепция мне понятна, так что можно
обойтись рассмотрением полезных встроенных функций:

#### Функция left(колонка, число символов).
Функция left отрезает от значения из строки в колонке число указанных символов и
возвращает в качестве результата

#### Оператор LIKE.
Использование оператора like похоже на использование регулярных выражений.
Оператор like используется совместно с шаблоном, в котором понатыканы символы
подстановки. Синтаксис таков:

```
mysql> select some_text from table1 where some_text like '_A_T%S';
```

В примере выше шаблон '_A_T%S' может быть рассмотрен как "Первый символ строки
может быть любым, на втором месте символ A, на третьем месте опять любой символ,
после чего должен следовать символ T на четвертом месте, затем любые символы в
любом количестве вполь до момента, когда будет встречен символ S, на котором
строка и должна закончиться."

Задача: какие три типа символов подстановки бывают?
* _ - любой одиночный символ;
* % - любое число любых символов;
* A - конкретный символ.

#### Регулярные выражения.
Регулярные выражения применяются таким образом:

```
select value from table1 where value regexp '^[QY]';
```

Собственно говоря, обычные регулярки. Изучив их синтаксис однажды- использовать
возможно везде.

### NUll.
Null в SQL несет такой же смысл, как и во всех остальных известных мне местах.
Но существует исключение: **С Null нельзя сравнивать**. То есть выражение value
!= NULL некорректно. Вместо этого с null необходимо использовать операторы
**is** и **not**.

## Запросы к нескольким таблицам.

Таблицы через join можно объединять различными способами. Одии из них является
Декартово произведение.

### Декартово произведение. Перекрестное соедниение.

```
mysql> select c.first_name, a.address from customer c join address a;
```

Этот запрос выведет порядка 360000 записей, при этом в таблицах customer и
address всего около 600 записей. А откуда же взялись 360000? Прсто СУБД
предложила все возможные сочетания людей и адресов, перемножив 600 на 600 и
получив 360000 возможных вариантов.

### Внутренее соединение.

Возможно поменять предыдщуий запрос так, чтобы для каждого человека выводился
лишь его адрес. Для этого в таблице с людями присутствует колонка address_id,
она является внешним ключом для таблицы address. В таблице adress также есть
колонка address_id, являющаяся первичным ключом этой таблицы.

Чтобы решить поставленную задачу следует придерживаться такой логики:
"Многоуважаемая СУБД, пожалуйста, обрати внимание на поле address_id в таблице
customer, пройди по связи и посмотри в таблице поле address, соответствующее
этому address_id".

Реализация этой логики такова:

```
mysql> select c.first_name, a.address from customer c join address a on c.address_id = a.address_id;
```

Если в одной из таблиц присутствует значение address_id, а в другой нет- то
такая строка исключается из результирующего набора. (Чтобы не исключать строки с
отсутствующими значениями применяется внешнее соединение.)

**В продемонстрированном выше запросе применялось именно внутреннее соединение,
просто неявно.**

А вот так выглядит его явная форма:

```
mysql> select c.first_name, a.address from customer c inner join address a on c.address_id = a.address_id;
```

Задача: как можно исключить использование ключевого слова on при внутреннем
объединении?

Если столбцы, по которым производится объединение, имеют одинаковое название,
можно сделать финт ушами: использовать ключевое слово using:

```
mysql> select c.first_name, a.address from customer c inner join address a using (address_id);
```

Правда в таком случае стоит использовать скобки -_-

### Синтаксис соединения ANSI.

Синтаксис ANSI является более старым по сравнению с используемым SQL92. Все
популярные СУБД поддерживают оба синтаксиса, в принципе, синтаксис ANSI может
быть удобен в некоторых случаях. На этом синтаксисе внутреннее объединение
таблиц будет выглядеть следующим образом:

```
mysql> select c.first_name, a.address from customer c, address a where c.address_id = a.address_id;
```

Алан Болье отмечает, что новый синтаксис SQL92 имеет преимущество в
переносимости между серверами, в то время как старый ANSI могут не поддерживать
СУБД, разработанные после 1992 года. Также синтаксис SQL92 выигрывает в условиях
сложных запросах:

SQL92
```
mysql> select c.first_name, c.last_name, a.address from customer c inner join address a using (address_id) where a.postal_code = 52137;
```

ANSI
```
mysql> select c.first_name, c.last_name, a.address from customer c, address a where c.address_id = a.address_id and a.postal_code = 52137;
```

Этот пример приводит автор книги и утверждает, что синтаксис SQL92 выглядит
проще, потому что проще увидеть условия объединения, а также наглядно показано,
какой вид объединения используется. На мой взгляд, это не показательный пример.

### Соединение трех и более таблиц.

Для соединения трех и более таблиц необходимо "пристыковать одну к другой и одну
к другой и так далее.

таблица1 inner join таблица2 using() inner join таблица3 using()

```
mysql> select c.first_name, ct.city from customer c inner join address using (address_id) inner join city ct using (city_id);
```

Задача: влияет ли порядок перечисления таблиц в from на результат?

Не влияет. SQL является декларативным языком, так что нет никакой разницы, в
каком порядке были перечислены таблицы. СУБД самостоятельно позаботится об
объединении. Но существует механимзм, позволяющий строго указать порядок, в
котором следует присовывать одну таблицу к другой. Для этого следует
использовать ключевое слово straight_join в MySQL, force order в SQL Server или
другой подобный механизм в других СУБД.

### Использоание подзапросов в качестве таблиц.

А вот, собственно говоря, что тут имеется ввиду:
В предыдущем параграфе мы использовали связь между таблицами customer и address
через address_id, а также связь между address и city через city_id.

Можно сделать по другому. Через подзапрос можно сформировать таблицу, которая
содержит address_id и city. А вот уже и появляется возможность связать customer
и city через address_id.

Вот пример реализации:

```
mysql> select c.first_name, ct.city from customer c inner join (select address.address_id, city.city from address inner join city using (city_id)) ct using (address_id);
```
### Использование одной таблицы дважды.

Иногда возникает потребность соединиться с одной и той же таблицей несколько
раз. Чтобы это сделать необходимо использовать псевдонимы и просто лишь
соединиться два раза.

Если для соединения с таблицей необходимо прибегнуть к соединению с
промежуточной таблицей- значит, необходимо несколько раз соединиться и с
промежуточной.

### Самосоединение.

Внутри таблицы может присутствовать столбец, являющийся внешним ключом, который
ведет на столбец с первичным ключом в этой же таблице. К примеру, в таблице с
информацией о фильмах может содержаться столбец, показывающий на приквел к
фильму. Применяя самосоединение можно составить таблицу, в которой будет все
фильмы, а также будут указаны все приквелы.

Синтаксис, используемый для такого соединения не отличается от примененного
ранее.

## Работа с множествами.

union - логическое ИЛИ
intersect - логическое И
except - Вычесть кусок

При воыполнении операций со множествами над таблицами должны выполняться
некоторые уловия:

- Число столбцов в таблицах должно быть одинаковым;
- Типы данных в соответствующих столбцах должны быть одинаковыми, или должна
  быть возможность преобразования одного типа данных в другой;

### Оператор union.

Помимо оператора union существует и оператор union all. Разница между ними
заключается в том, что union удаляет дубликаты из результирующего набора в
отличие от union all.

```
mysql> select 1 num, 'a' str union select 1 num, 'a' str;     
+-----+-----+
| num | str |
+-----+-----+
|   1 | a   |
+-----+-----+
mysql> select 1 num, 'a' str union all select 1 num, 'a' str;
+-----+-----+
| num | str |
+-----+-----+
|   1 | a   |
|   1 | a   |
+-----+-----+
```

### Оператор intersect.

Пересечение. Также удаляет дубликаты, оператор intersect all дубликаты не
удаляет, а вообще этот оператор поддерживается далеко не всеми версиями MySQL.

### Оператор except.

Оператор except возвращает первый указанный набор за вычетом свопадающих
результатов из второго набора.

Также есть его разновидность- except all. Except all не отбрасывает дубликаты в
результирующем наборе.

## Генерация, обработка и преобразование данных.

### Управление точностью чисел.

- ceil() округляет к ближайшему большему целому числу;
- floor() округляет к ближайшему меньшему целому числу;
- round() округляет к ближайшему целому (если дробная часть больше либо равна
  0.5, то округление произойдет в большую сторону), вторым параметром можно
  указать число знаков после запятой в итоговом результате;
- truncate() всегда принимает два аргумента и отбрасывает столько знаков после
  запятой, чтобы их осталось ровно столько, сколько передано во втором
  параметре.

## Группировка и агрегация.

### Группировка.
Пусть есть таблица с данными о том, какой фильм, каким клиентом был взят на
прокат. В этой таблице хранится id клиента идентификатор фильма. Вполне вероятна
ситуация, при которой число строк в этой таблице больше чем число клиентов.
Просто клиенты брали больше одного фильма в аренду. Как в таком случае
посмотреть, какой клиент сколько фильмов брал?

Ответом становится группировка и агрегация. Необходимо запросить из таблицы
группированные данные по клиентам и агрегировать количество взятых ими фильмов.
Вот так может выглядеть такой запрос:

```
mysql> select customer_id, count(*) from rental group by customer_id;
```

Предложение group by будто бы разбивает таблицу rental на множество таблиц для
каждого значения customer_id. Затем применяется функция агрегации, вычисляющая
одно единственное значение для каждой из маленьких таблиц.

Стоит напомнить себе порядок выполнения предложений в SQL:
1) FROM;
2) WHERE;
3) GROUP BY;
4) HAVING;
5) SELECT.

### Агрегация.

Агрегатные функции призваны уместить множество значений в одно. Будь то
максимальное или минимальное значение в наборе, среднее значение или их
количество.

- max();
- min();
- avg();
- sum();
- count();

### Неявная и явная группировки.

При выполнении такого запроса появляется одна неявная группа- единственная
строка, содержащая результат выполнения функции агрегирования.

Во всех остальных случаях необходимо явно указывать способ группировки.

### Многостолбцовая группировка.

При группировки по нескольким столбцам, они перечисляются через запятую после
предложения GROUP BY без скобок.

### Генерация итоговых данных. WITH ROLLUP

Предложение WITH ROLLUP позволяет получить результирующий набор, в котором
возникнут дополнительные строки. В этих дополнительных строках будет записан
результат вычисления агрегатной функции но над группой.

К примеру добавление WITH ROLLUP к запроу, выводящему список актеров, список
рейтингов фильмов, в которых актер снимался, а также число фильмов для каждого
рейтинга, приведет к тому, что появятся дополнительные строки, содержащие общее
число фильмов, в которых снялся актер.

Пример без WITH ROLLUP

```
mysql> select fa.actor_id, f.rating, count(*) from film_actor fa inner join film f using (film_id) group by fa.actor_id, f.rating order by 1,2 limit 10;    
+----------+--------+----------+
| actor_id | rating | count(*) |
+----------+--------+----------+
|        1 | G      |        4 |
|        1 | PG     |        6 |
|        1 | PG-13  |        1 |
|        1 | R      |        3 |
|        1 | NC-17  |        5 |
|        2 | G      |        7 |
|        2 | PG     |        6 |
|        2 | PG-13  |        2 |
|        2 | R      |        2 |
|        2 | NC-17  |        8 |
+----------+--------+----------+
```

С WITH ROLLUP:

```
mysql> select fa.actor_id, f.rating, count(*) from film_actor fa inner join film f using (film_id) group by fa.actor_id, f.rating with rollup order by 1,2 limit 10; 
+----------+--------+----------+
| actor_id | rating | count(*) |
+----------+--------+----------+
|     NULL | NULL   |     5462 |
|        1 | NULL   |       19 |
|        1 | G      |        4 |
|        1 | NC-17  |        5 |
|        1 | PG     |        6 |
|        1 | PG-13  |        1 |
|        1 | R      |        3 |
|        2 | NULL   |       25 |
|        2 | G      |        7 |
|        2 | NC-17  |        8 |
+----------+--------+----------+
```

## Подзапросы

Подзапрос - запрос, содержащийся в другой инстркуции данных. Как и любой запрос
подзапрос возвращает результирующий набор, который может быть одного из трех
видов:
- одна строка, один столбец (скалярный подзапрос);
- несколько строк, один столбец (могут быть использованы в сочетании с in, not
  in, all, any. Использование all и any подразумевает также и использование
  операторов сравнения);
- несколько строк, несколько столбцов.

Результаты, возвращаемые подзапросами, являются временными таблицами.
Соответственно, когда вызывающая инструкция завершает выполнение, все результаты
подзапроса с памяти убираются.

Вот, как выглядит поздапрос:

```
mysql> select customer_id, first_name, last_name from customer where customer_id = (select max(customer_id) from customer);        
+-------------+------------+-----------+
| customer_id | first_name | last_name |
+-------------+------------+-----------+
|         599 | AUSTIN     | CINTRON   |
+-------------+------------+-----------+
```

Приведенный выше подзапрос участвует в предложении where. Он возвращает таблицу
с одной единственной строкой и одним столбцом. Это дает возможность использовать
результат подзапроса с оператором вычисления равенства. Если бы подзапрос вернул
несколько строк, его можно было бы использовать с операторами больше и меньше.
Но не с оператором равенства. В итоге запрос возвращает имя, фамилию и id
клиента с максимальным значением id.

Может показаться, что использовать подзапрос в этом случае вовсе необязательно и
можно обойтись подобным запросом:

```
mysql> select customer_id, first_name, last_name from customer where customer_id = max(customer_id);
```

Но нет, так сделать нельзя. СУБД ругается на неправильное применение функции к
группе. Думаю, суть в том, что max(customer_id имеет смысл только при применении
в теле запроса, то есть select max()).

Задача: что такое скалярный запрос?

Подзапросы можно разделить на два вида:
- некоррелированные;
- коррелированные.

Некоррелированные запросы независимы и могут выполняться автономно,
коррелированные же напротив, требуют наличия родительского запроса, потому что
ссылаются на значения из него. Помимо этого коррелированные запрос выполняется
для каждого значения из родительского набора данных.

Подзапросы могут участвовать как в инструкции select, так и в инструкциях
update, delete, insert.

### Подзапросы, возвращающие один столбец и несколько строк.

Подзапрос может вернуть несколько строк с одни столбцом и в таком случае его
нельзя использовать в условии равенства. Но существуют четыре оператора, которые
позволяют использовать такой подзапрос:

1) in;
2) not in;
3) all;
4) any.

#### Оператор in

Этот оператор может использоваться в условии проверки вхождения одного
единственного значения в множество значений, возвращенных подзапросом. К примеру
сделаем две таблицы, в одной будут значения 1, 2 и 3. А в другой будут 2, 3, 4,
а также 5. А теперь запросим такие значения из первой таблицы, которые
присутствуют и во второй:

```
mysql> select value from t1 where value in (select value from t2);
+-------+
| value |
+-------+
|     2 |
|     3 |
+-------+
```

Ответ именно такой, какой и следовало бы ожидать. Естественно, конкретно эту
задачу можно было бы решить и с применением оператора пересечения:

```
mysql> select value from t1 intersect select value from t2;
+-------+
| value |
+-------+
|     2 |
|     3 |
+-------+
```

Примененный подзапрос, в принципе, делает ровно то же самое, что и "where value
in (2, 3, 4)" или "where value = 2 of value = 3 or value = 4". Но применение
подзапроса выглядит куда лучше.

#### Оператор not in.

Оператор not in делает то же самое, что и in, но наоборот. Вот такие дела.

#### Оператор all.

Оператор all позволяет сравнить значение с целым набором значений. К примеру,
больше ли значение всех остальных значений в наборе. В сочетании с оператором
all следует применять операторы сравнения: <, >, != и так далее.

К примеру, для таблицы со значениями 1, 3, 5 можно выбрать только те значения,
которые меньше любого значения из таблицы со значениями 2, 4, 6 с помощью такого
запроса:

```
select value from t1 where value < all (select value from t2);
```

Задача: а что будет, если в множестве, с которым выполняется сравнение с
помощью операторов all или not in окажется null?

Вернется пустой набор. А происходит это по причине того, что СУБД сравнивает
значение слева с каждым из значений справа. А любая попытка сравнения c Null
приводит к Null.

```
mysql> select 1 > 2;    
+-------+
| 1 > 2 |
+-------+
|     0 |
+-------+

mysql> select 2 > 1; 
+-------+
| 2 > 1 |
+-------+
|     1 |
+-------+
1 row in set (0.00 sec)

+----------+
| 1 > null |
+----------+
|     NULL |
+----------+
```

#### Оператор any.

Оператор any похож на all, но результат его выполнения становится истиным только
в случае, если нашлось хотя бы одно значение в множестве, для которого
выполнилось условие. К примеру value больше хотя бы одного значения из (select
...)

Продемонстрируем это на таблицах содержащих числа 1, 10, 50:

```
mysql> select 1 where 1 > any (select value from t1);
Empty set (0.00 sec)

mysql> select 1 where 2 > any (select value from t1); 
+---+
| 1 |
+---+
| 1 |
+---+
```

1 меньше любого значения из таблицы t1. А вот 2 уже больше одного из значений
набора.

### Многостолбцовые подзапросы.

Многостолбцовые запросы могут быть использованы с операторами not in и in.
Просто сравнивать необходимо несколько столбцов с несколькими столбцами, которые
возвращает подзапрос.

### Коррелированные подзапросы.

Коррелированный подзапрос зависит от содержащей его инструкции, поскольку
ссылается на один или несколько её столбцов. Некоррелированный подзапрос
выполняется лишь один раз перед содержащей его инструкции, а вот коррелированный
напротив, выполняется каждый раз для строки- кандидата (строки, которая может
быть включена в результирующий набор).

В качестве демонстрации может быть рассмотрен такой пример:
Есть таблица, описывающая клиентов. В ней есть id и имя с фамилией каждого
клиента. Также существует таблица с записями о том, какой фильм брали клиенты с
перечислением их id. А есть задумка: вывести имена тех клиентов, которые брали
ровно 19 фильмов.

Задача может решаться по- разному. Можно соединить таблицы, сгруппировать по id,
отфильтровать тех, у кого count(*) в мини- табличке окажется равным 19 запросить
имена этих клиентов. С другой стороны можно обойтись и без соединения таблиц, а
с применением подзапроса. Нужно лишь, чтобы подзапрос возвращал количество
взятых напрокат фильмов для клиента с конкретным id.

Пожалуй, стоит привести пример подобного запроса:

```
select count(*) from rental where rental.customer_id = какой-то_конкретный_id;
```

Вот тут и становится понятно, что такое коррелированный подзапрос. Для
исполнения приведенного выше подзапроса необходим какой-то_конкретный_id,
единственный известный мне способ- предоставить его из родительского запроса.
Родительский запрос может выглядеть так:

```
select customer.first_name from customer;
```

Просто напросто запрашиваем строки из customer, тем самым получая и customer_id.
Теперь же соединим два запроса воедино:

```
mysql> select c.first_name from customer c where (select count(*) from rental r where r.customer_id = c.customer_id) = 19;
```

Рассмотрим другую ситуацию. Опять же есть таблица с клиентами. А также есть
таблица транзакций клиентов. В таблице транзакций собрана информация о том,
какой клиент, какую сумму оплачивал. Пускай опять есть задумка: запросить имена
тех клиентов, которые в итоге заплатили больше 100 у.е.

Сразу перейдем к делу: необходимо запрашивать имена из таблицы клиентов, а
затем, запрашивать сумму всех операций из таблицы транзакций для этого клиента.

```
mysql> select c.first_name from customer c where (select sum(p.amount) from payment p where p.customer_id = c.customer_id) > 100;
```

Ради разнообразия, решим эту задачу с помощью join.

```
mysql> select c.first_name from customer c inner join payment p using (customer_id) group by c.customer_id having sum(p.amount) > 100;
```

Оба этих запроса выдают одинаковый результат.

#### Оператор exists.

Оператор exists позволяет проверить, существует ли набор. Применение оператора
exists возвращает true в случае, если запрос (подзапрос) вернул не пустой набор.
К примеру:

```
mysql> select 1 where exists (select 1 where 1);
+---+
| 1 |
+---+
| 1 |
+---+
```

```
mysql> select 1 where exists (select 1 where 0);
Empty set (0.00 sec)
```

Рассмотрим более реалистичный случай. Пусть имеется таблица клиентов. А также
имеется таблица, в которой собрана информация о том, какой клиент какой фильм на
прокат взял. Задумка состоит в том, что есть желание найти таких клиентов,
которые взяли фильм на прокат до 25.05.2005.

Решение такой задачки через оператор exists состоит в следующем: необходимо
добавлять в итоговый набор таких клиентов, для которых существует набор фильмов,
которые они взяли на прокат до 25.05.2005.

```
mysql> select c.first_name from customer c where exists (select 1 from rental r where date(r.rental_date) < '2005-05-25' and r.customer_id = c.customer_id);
```

Попробуем решить другую задачку. Нам необходимо найти всех актеров, которые не
снимались в фильмах с рейтингом R. Для этого необходимо добавлять имена актеров
из таблицы актеров, если для них не существует набора фильмов с рейтингом R.

```
mysql> select a.first_name from actor a where not exists (select 1 from film f inner join film_actor fa using (film_id) where fa.actor_id = a.actor_id and f.rating = 'R');
+------------+
| first_name |
+------------+
| JANE       |
+------------+
```

### Работа с данными при помощи коррелированных подзапросов

Алан Болье утверждает о том, что коррелированные запросы чаще встречаются в
инструкциях update и delete. К примеру, с помощью такого запроса можно увеличить
все значения в колонке в два раза:

```
mysql> update t1 set value = (select t1.value * 2);
```

Естественно, необходимо, чтобы подзапрос был скалярным. Иначе произойдет что- то
странное и Вселенная схлопнется.

В более приближенном к реальности примере попробуем обновить дату последнего
взятия в аренду фильма в таблице клиентов на дату последнего взятия фильма из
таблицы взятия фильмов :-).

```
mysql> update customer c set c.last_update = (select max(r.rental_date) from rental r where r.customer_id = c.customer_id);
```

Тут путника может подстерегать угроза. Если в таблице rental по какой- то
причине не окажется взятого на прокат фильма (как он тогда может быть клиентом),
то в поле last_update клиенту запихнется Null, поскольку подзапрос вернет пустой
набор (потому что клиент не будет числиться в таблице взятия фильмов). Лучше
держать это в голове, а еще лучше добавить проверку.

Проверка будет выражена через другой подзапрос. Который будет проверять
существование в таблице взятия фильмов записи с конкретным id клиента:

```
mysql> update customer c set c.last_update = (select max(r.rental_date) from rental r where r.customer_id = c.customer_id) where exists (select 1 from rental r where r.customer_id = c.customer_id);
```

Второй подзапрос проверяет наличие записей о клиенте в таблице взятия фильмов.
Если клиент брал фильм на прокат- он есть в этой таблице. Select в этом случае
возвращает набор, состоящий из такого числа единиц, сколько существует записей,
связанных с клиентом. На основании этого фильтруются строки- кандидаты из
таблицы customer.

### Применение подзапросов.

Использование подзапросов не ограничивается только лишь нахождением условия для
удаления или выборки чего- нибудь. Помимо этого подзапросы возможно с успехом
применять в качестве инструмента для создания таблиц и генерации значений.

#### Подзапросы как источники данных.

Как мы помним, предложение from определяет тот набор таблиц, который будет
использоваться для дальнейшей обработки. Но вообще- то помимо таблиц как таковых
можно использовать и результаты подзапроса. Лишь бы он что- то возвращал. А вот
то, что возвращает подзапрос, уже может быть использовано как полноценная
таблица. Главное- навесить псевдоним.

Допустим, задачка: запросить имена и фамилии клиентов, а также число фильмов,
которые они брали напрокат и общую сумму денег, полученную от них. Две последнии
информации хранятся в таблице payment, первые две в customer. Их связывает
customer_id и его вполне можно было бы использовать для решения такой задачки:

```
mysql> select c.first_name, c.last_name, count(*) num_rentals, sum(p.amount) total_payments from customer c inner join payment p using (customer_id) group by c.customer_id;
```

Но также эту задачу можно решить с применением подзапроса:

```
mysql> select c.first_name, c.last_name, pmnts.num_rentals num_rentals, pmnts.total_payments total_payments from customer c inner join (select p.customer_id, count(*) num_rentals, sum(amount) total_payments from payment p group by customer_id) pmnts using (customer_id);
```

Подзапрос формирует таблицу из интересующих нас полей в таблице payment, а также
с ключом customer_id, по которому то мы и можем связать две таблицы.

Важное упоминание: подзапросы, применяемые в предложении from должны быть
некоррелированными. При выполнении главного запроса СУБД сперва выполнит
подзапросы, чтобы получить исходные наборы данных и сохранит их в оперативной
памяти. А это в свою очередь означает, что когда будет, допустим, происходить
изменение данных, на которые ссылаются коррелированные подзапросы- условия не
будут динамически изменяться. Да и вообще страшно подумать о том, что произойдет
при попытке менять данные во время их использования для составления неких
условий. Это почти как итерироваться по динамическому массиву и параллельно его
в размерах менять, только хуже.

Использование коррелированных подзапросов вроде как запрещено на уровне СУБД. Но
некоторые СУБД позволяют все таки их применять через cross apply или external
apply или еще что- нибудь в таком духе.

#### Подзапросы для создания данных.

Помимо того, чтобы тем или иным образом комбинировать существующие данные, с
помощью подзапросов можно нагенерировать таких данных, которые нельзя получить
никаким иным способом из базы данных.

К примеру, захотели мы распределить клиентов по группам. А группы мы еще и сами
понапридумывали. Сделать это мы можем с помощью трех селектов и парочки объединений.

```
mysql> select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit;
+---------------+-----------+------------+
| name          | low_limit | high_limit |
+---------------+-----------+------------+
| Small Fry     |         0 |      74.99 |
| Average Joes  |        75 |     149.99 |
| Heave Hitters |       150 | 9999999.99 |
+---------------+-----------+------------+
```

Что мы сделали? Мы сделали три селекта, каждый из которых вернул нам таблицу из
одной строки с тремя столбцами. Далее благодаря объединению мы их запихнули в
одну таблицу (нельзя забывать о том, что union работает лишь с таблицами с
равным числом колонок).

А теперь, раз у нас появилась такая чудесная таблица с группами, можно её
использовать с другими данными. Найдем распределение по группам всех клиентов:

```
mysql> select payment_groups.name, count(*) num_customers from (select customer_id, sum(amount) from payment group by customer_id) payments inner join (select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit) payment_groups on payments.customer_id between payment_groups.low_limit and payment_groups.high_limit group by payment_groups.name;
+---------------+---------------+
| name          | num_customers |
+---------------+---------------+
| Small Fry     |            74 |
| Average Joes  |            75 |
| Heave Hitters |           450 |
+---------------+---------------+
```

```
select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit
```

Запрос выглядит страшно, но все таки разберемся с ним. Сперва поймем, что мы
вообще хотим. А хотим мы получить название группы и число клиентов, которые туда
попали. Таким образом в изначальном select'е точно будем запрашивать название
группы name из таблицы, формируемой подзапросом, описанным выше, а также будем
вызывать функцию sum(). Ну и еще будем группировать, но об этом позже.

Значит, точно в from пишем подзапрос, формирующий группы:

```
mysql> select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit;
+---------------+-----------+------------+
| name          | low_limit | high_limit |
+---------------+-----------+------------+
| Small Fry     |         0 |      74.99 |
| Average Joes  |        75 |     149.99 |
| Heave Hitters |       150 | 9999999.99 |
+---------------+-----------+------------+
```

Этого не достаточно, далее мы получить таблицу содержащуюю потраченные деньги по
клиентам. То есть необходимо подзапросить сумму всех оплат из таблицы payment,
группированную по клиентам:

```
mysql> select sum(amount) total_payment from payment group by customer_id;
+---------------+
| total_payment |
+---------------+
|        118.68 |
|        128.73 |
.
.
.
|         83.78 |
|         83.81 |
+---------------+
599 rows in set (0.01 sec)
```

Теперь необходимо использовать "прикол" и соединить полученные таблицы на
основании не равенства как такового, а на основании принадлежности к диапазону:

```
mysql> ... (первый запрос) название1 inner join (второй запрос) название2 on название2.total_payments between название1.low_limit and название1.high_limit;
+---------------+-----------+------------+---------------+
| name          | low_limit | high_limit | total_payment |
+---------------+-----------+------------+---------------+
| Average Joes  |        75 |     149.99 |        118.68 |
| Average Joes  |        75 |     149.99 |        128.73 |
.
.
.
| Average Joes  |        75 |     149.99 |         83.81 |
+---------------+-----------+------------+---------------+
599 rows in set (0.02 sec)
```

Отлично, теперь остается лишь разбить это по группам и посчитать количество в
каждой группе. select название1.name, count(*) ... group by название1.name

#### Подзапросы, ориентированные на задачу.

Допустим, есть задачка: запросить имена, фамилии, а также общее количество денег,
которые принесли клиенты и количество фильмов, взятых ими напрокат. Задачку
можно решить, соединив несколько таблиц, а именно customer и payment. Их
необходимо соединить и разбить по группам:

```
mysql> select c.first_name, c.last_name, sum(p.amount) total_payments, count(*) total_rentals from customer c inner join payment p using (customer_id) group by c.first_name, c.last_name;
```

Можно поступить иначе. Через подзапрос сформировать таблицу значений с
cusotmer_id, общей суммой потраченных средств и числом взятых напрокат фильмов.
А затем соединить эти две таблицы воедино:

```
mysql> select c.first_name, c.last_name, pmnts.total_payments, pmnts.total_rentals from customer c inner join (select customer_id, sum(amount) total_payments, count(*) total_rentals from payment group by customer_id) pmnts using (customer_id) group by customer_id;
```

Второе решение задачки предпочтительнее по скорости выполнения по причине
выполнения группировки по числовому столбцу, а не по нескольким строковым.

#### Обобщенные табличные выражения. CTE.

CTE или Common table expressions появились в восьмой версии MySQL и являются
подзапросами. Внешней особенностью их является то, что они запрашиваются с
использованием предложения with. А помимо этого каждый вложенный подзапрос
обладает возможностью обращаться к значениям из родительского подзапроса. Такая
цепочка разделения области видимости реализуется в рамках одного with. Еще автор
утверждает, что так подзапросы становятся проще для зрительного восприятия.

Чтобы продемонстрировать CTE, реализуем запрос, который возвращает id и имя
клиента, но эту информацию он будет брать из CTE:

```
mysql> with id_name as (select customer_id id, first_name name from customer) select id, name from id_name;
+-----+-------------+
| id  | name        |
+-----+-------------+
|   1 | MARY        |
|   2 | PATRICIA    |
|   3 | LINDA       |
```

Теперь добавим еще один подзапрос, который будет коррелировать с родительским и
возвращать лишь те строки, в которых id в пределах от 10 до 15:

```
mysql> with id_name as (select customer_id id, first_name name from customer), filtered_id_name as (select id, name from id_name where id between 10 and 25) select id, name from filtered_id_name;
+----+---------+
| id | name    |
+----+---------+
| 10 | DOROTHY |
| 11 | LISA    |
| 12 | NANCY   |
| 13 | KAREN   |
| 14 | BETTY   |
| 15 | HELEN   |
+----+---------+
```

Как было продемонстрировано, второй CTE получает возможность обращаться к
первому, а внутри основного запроса все эти CTE становятся виртуальными
таблицами, доступными в предложении from.

#### Подзапросы как генераторы выражений.

Чуть ранее мы решали задачку о выборке имен, фамилий, общей суммы потраченных
клиентами денег и числом фильмов, которые они взяли напрокат. Мы решили эту
задачку двумя способами. В первом случае произвели соединение всего и вся в одну
здоровенную таблицу, затем прогруппировали по имени и фамилии, параллельно
высчитывая агрегатные функции.

Во втором случае мы сформировали через подзапрос значения суммы платежей и числа
взятых напрокат фильмов для каждого конкретного customer_id, а затем произвели
соединение.

Существует и третий вариант решения этой задачи (как мы помним, если существует
один алгоритм, приводящий к успеху- существует и бесконечное множество других
способ достичь того же результата). Так вот, третий способ заключается в том,
чтобы с помощью скалярных запросов вычислять значения колонок для каждого
customer_id. Примерно как тут:

```
mysql> select (select first_name from customer cus where cus.customer_id = c.customer_id ) name from customer c limit 2;
+----------+
| name     |
+----------+
| MARY     |
| PATRICIA |
```

Теперь провернем такой же трюк, но со всеми колонками, интересующими нас в
результирующем наборе:

```
mysql> select (select c.first_name from customer c where c.customer_id = p.customer_id) first_name, (select c.last_name from customer c where c.customer_id = p.customer_id) 
last_name, sum(amount) total_payments, count(*) total_rentals from payment p group by customer_id;
```

Этот запрос вернет анологичный результирующий набор.

### Заключение о подзапросах.

В заключение стоит подытожить:
1) Подзапросы бывают коррелированными и некоррелированными. Коррелированным
   подзапросом называется такой, внутри которого указано значение из
   обрамляющего запроса;
2) Подзапросы могут возвращать одно единственное значение и в таком случае они
   называются скалярными. Могут возвращать таблицу, состояющую из одной колонки
   и многих строк, в таком случае их удобно использовать с специальными
   операторами in, not in, exists и not exists, а также all.
3) Подзапросы можно запихнуть в Common Table Expression (CTE), чтобы получить
   возможность красиво создавать временные таблицы и обращаться к ним по мере
   необходимости.

## Соединения.

### Внешнее соединение.

Соединения бывают разные и пока что мне удалось поработать лишь с одни видом
соединений, а именно с внутренним соединением.

В базе данных, которую я использую, существует две таблицы: film и inventory. В
таблице film содержится 1000 строк, а в таблице inventory уникальных id фильмов
лишь 958. При использовании inner join при соединении этих двух таблиц в набор
попадут лишь 958 строк. Чтобы убедиться в этом, напишем следующего вида запрос:

```
mysql> select f.film_id, count(i.inventory_id) from film f inner join inventory i using (film_id) group by film_id;
|     998 |        2 |
|     999 |        5 |
|    1000 |        8 |
+---------+----------+
958 rows in set (0.00 sec)
```

А получается, что некоторые фильмы из таблицы film не попали в результирующий
набор, а именно целых 1000 - 958 = 42 штуки.

Запрос отбросил 42 фильма по причине того, что в inventory.film_id не оказалось
значения из колонки film.film_id. Эту ситуацию можно исправить, если применить
внешнее соединение:

```
mysql> select f.film_id, count(i.inventory_id) from film f left outer join inventory i using (film_id) group by film_id;
+---------+-----+
| film_id | cnt |
+---------+-----+
|      14 |   0 |
.
.
.
|     973 |   8 |
|    1000 |   8 |
+---------+-----+
1000 rows in set (0.01 sec)
```

Теперь запрос возвращает 1000 строк, причем тем фильмам, которые раньше
отбрасывалиcь, назначается 0 в столбце числа доступных для проката копий.
Происходит это потому что фильма с id, к примеру 14, нет в таблице inventory,
значит и число копий для него 0.

```
mysql> select * from inventory where film_id = 14;               
Empty set (0.00 sec)
```

Применение left outer по сравнению с inner привело к тому, что СУБД стала
добавлять в итоговый набор все строки из таблицы из левой части выражения
соединения и включения столбцов из правой стороны выражения. Другими словами:
СУБД запихнула строку из таблицы film, для которой нет информации в таблице
inventory. То есть нет столбцов именно правой таблицы. Получается, что СУБД
нарисовала столбцы правой таблицы для строки из левой таблицы.

Чтобы нагляднее посмотреть, что происходит, запросим id фильмов в диапазоне от
13 до 15 из таблицы film, их названия и инвентарные номера из таблицы inventory
при внутреннем соединении:

```
mysql> select f.film_id, f.title, i.inventory_id from f inner join inventory i using(film_id);
+---------+--------------+--------------+
| film_id | title        | inventory_id |
+---------+--------------+--------------+
|      13 | ALI FOREVER  |           67 |
|      13 | ALI FOREVER  |           68 |
|      13 | ALI FOREVER  |           69 |
|      13 | ALI FOREVER  |           70 |
|      15 | ALIEN CENTER |           71 |
|      15 | ALIEN CENTER |           72 |
|      15 | ALIEN CENTER |           73 |
|      15 | ALIEN CENTER |           74 |
|      15 | ALIEN CENTER |           75 |
|      15 | ALIEN CENTER |           76 |
+---------+--------------+--------------+
10 rows in set (0.00 sec)
```

А теперь провернем ту же самую процедуру, но при внешнем левом соединении:

```
mysql> select f.film_id, f.title, i.inventory_id from film f left outer join inventory i using (film_id) where f.film_id between 13 and 15;      
+---------+----------------+--------------+
| film_id | title          | inventory_id |
+---------+----------------+--------------+
|      13 | ALI FOREVER    |           67 |
|      13 | ALI FOREVER    |           68 |
|      13 | ALI FOREVER    |           69 |
|      13 | ALI FOREVER    |           70 |
|      14 | ALICE FANTASIA |         NULL |
|      15 | ALIEN CENTER   |           71 |
|      15 | ALIEN CENTER   |           72 |
|      15 | ALIEN CENTER   |           73 |
|      15 | ALIEN CENTER   |           74 |
|      15 | ALIEN CENTER   |           75 |
|      15 | ALIEN CENTER   |           76 |
+---------+----------------+--------------+
11 rows in set (0.00 sec)
```

Появлилась строчка с фильмом с id 14. А его инвентарный номер значится как null.
Это произошло потому что, для этого фильма нет информации в этой колонке в
таблице inventory (как и для любой другой колонки). В этой ситуации не
выполнилось условие соединения, что бы это не значило, а в таком случае все
столбцы, извлеченные из внешне соединенной таблицы будут нести значение null.

### Левые и правые соединения.

Ключевое слово left показывает, что таблица в левой части выражения отвечает за
количество строк в результирующем наборе, а таблица из правой части отвечает за
предоставление значений столбцов. Либо null.

Возможно заменить left на right и ситуация симметрично изменится. Правая таблица
будет отвечать за число строк, а левая за значения в столбцах:

```
mysql> select f.film_id, f.title, i.inventory_id from inventory i right outer join film f using (film_id) where f.film_id between 13 and 15;
+---------+----------------+--------------+
| film_id | title          | inventory_id |
+---------+----------------+--------------+
|      13 | ALI FOREVER    |           67 |
|      13 | ALI FOREVER    |           68 |
|      13 | ALI FOREVER    |           69 |
|      13 | ALI FOREVER    |           70 |
|      14 | ALICE FANTASIA |         NULL |
|      15 | ALIEN CENTER   |           71 |
|      15 | ALIEN CENTER   |           72 |
|      15 | ALIEN CENTER   |           73 |
|      15 | ALIEN CENTER   |           74 |
|      15 | ALIEN CENTER   |           75 |
|      15 | ALIEN CENTER   |           76 |
+---------+----------------+--------------+
11 rows in set (0.00 sec)
```

Замечание состоит в том, что в обоих случаях сервер выполняет соединение таблиц.
Ключевые слова left и right лишь дают понять СУБД о том, в какой таблице может
не доставать данных. Данных больше в левой- значит left outer, больше в правой-
right outer.

Не все СУБД поддерживают right outer join, так что автор рекомендует
использовать только left outer join. Помимо этого outer является еще и
необязательным словом, так что его можно и не использовать, но автор так делать
не рекомендует.

### Трехсторонние внешние соединения.

Возможно соединять и более двух таблиц используя внешнее соединение. Чтобы к
предыдущему запросу пристыковать еще и колонку последнего взятия фильма в
прокат, присоединим и таблицу rental:

```
mysql> select f.film_id, f.title, count(i.inventory_id), max(r.rental_date) from film f left join inventory i using (film_id) left join rental r using (inventory_id) group by f.film_id having f.film_id between 13 and 15; 
+---------+----------------+-----------------------+---------------------+
| film_id | title          | count(i.inventory_id) | max(r.rental_date)  |
+---------+----------------+-----------------------+---------------------+
|      13 | ALI FOREVER    |                     9 | 2006-02-14 15:16:03 |
|      14 | ALICE FANTASIA |                     0 | NULL                |
|      15 | ALIEN CENTER   |                    22 | 2005-08-23 19:21:22 |
+---------+----------------+-----------------------+---------------------+
```

Таким образом мы все состыковали, и получили интересующий нас результат.

### Перекрестные соединения.

Перекрестное соединение представляет собой декартово произведения. То все
возможные комбинации значений из таблиц. Продемонстрировать это стоит на простом
примере. Пусть есть таблицы t1 и t2. В таблице t1 хранятся значения 1, 2 и 3, а
в таблице t2 4, 5 и 6. Соединим их через cross join:

```
mysql> select * from t1 cross join t2 order by t1.value, t2.value;
+-------+-------+
| value | value |
+-------+-------+
|     1 |     4 |
|     1 |     5 |
|     1 |     6 |
|     2 |     4 |
|     2 |     5 |
|     2 |     6 |
|     3 |     4 |
|     3 |     5 |
|     3 |     6 |
+-------+-------+
9 rows in set (0.00 sec)
```

Чего и следовало ожидать, результирующий набор состоит из всех возможных
комбинаций значений таблиц t1 и t2.

Обычно говорят, будто перекрсестное соединение не особо полезно. Но Алан Болье
утверждает об обратном. Ранее мы уже использовали запрос для генерации таблицы с
тремя строками, представляющей собой категории клиентов. Вот этот запрос:

```
mysql> select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit;
+---------------+-----------+------------+
| name          | low_limit | high_limit |
+---------------+-----------+------------+
| Small Fry     |         0 |      74.99 |
| Average Joes  |        75 |     149.99 |
| Heave Hitters |       150 | 9999999.99 |
+---------------+-----------+------------+
```

А что, если мы хотим провернуть подобный трюк, но создать таблицу с днями года?
В таком случае придется писать запрос на более чем три сотни строк, а это
утомительно. Вместо мы можем воспользоваться перекрестным соединением:

```
select ones.num + tens.num + hundreds.num days
from
(select 0 num union
select 1 num union
select 2 num union
select 3 num union
select 4 num union
select 5 num union
select 6 num union
select 7 num union
select 8 num union
select 9 num) ones
cross join
(select 0 num union
select 10 num union
select 20 num union
select 30 num union
select 40 num union
select 50 num union
select 60 num union
select 70 num union
select 80 num union
select 90 num) tens
cross join
(select 0 num union
select 100 num union
select 200 num union
select 300 num) hundreds
order by days;
```

Этот запрос вернет таблицу с одной колонкой days, в которой будут числа от 0 до
399. (10 возможных значений единиц * 10 возможных значений десятков * 4
возможных значений сотен = 400 значений).

Далее необходимо от набора чисел перейти к набору дат. А этого можно добиться
через применение функции date_add(), прибавляя числа к фиксированной дате,
например к 2021 году:

```
select date_add('2021-01-01', interval (ones.num + tens.num + hundreds.num) day) dt
from
(select 0 num union
select 1 num union
select 2 num union
select 3 num union
select 4 num union
select 5 num union
select 6 num union
select 7 num union
select 8 num union
select 9 num) ones
cross join
(select 0 num union
select 10 num union
select 20 num union
select 30 num union
select 40 num union
select 50 num union
select 60 num union
select 70 num union
select 80 num union
select 90 num) tens
cross join
(select 0 num union
select 100 num union
select 200 num union
select 300 num) hundreds
where date_add('2021-01-01', interval (ones.num + tens.num + hundreds.num) day) < '2022-01-01'
order by 1;
```

Этот запрос вернет таблицу, состоящую из дат за 2021 год. Автор содержит в тайне
правила синтаксиса для применения функции date_add, ну да ладно.

А что теперь с этим делать? А можно составить запрос, возвращающий информацию о
том, сколько фильмов в какой день было взято. Для этого нужно произвести внешнее
соединение с таблицей rental, сгруппировать по дням и посчитать число
rental_date.

```
select date_t.dt, count(rental.rental_date) from rental
right join
(select date_add('2005-01-01', interval (ones.num + tens.num + hundreds.num) day) dt
from
(select 0 num union
select 1 num union
select 2 num union
select 3 num union
select 4 num union
select 5 num union
select 6 num union
select 7 num union
select 8 num union
select 9 num) ones
cross join
(select 0 num union
select 10 num union
select 20 num union
select 30 num union
select 40 num union
select 50 num union
select 60 num union
select 70 num union
select 80 num union
select 90 num) tens
cross join
(select 0 num union
select 100 num union
select 200 num union
select 300 num) hundreds
where date_add('2005-01-01', interval (ones.num + tens.num + hundreds.num) day) < '2006-01-01') date_t
on date(rental.rental_date) = date_t.dt
group by date_t.dt
```

### Естественные соединения.

При использовании естественного соединения забота о том, как соединить таблицы
целиком и полностью основывается на СУБД. Ключевым словом для такого соединения
выступает natural join. Естественное соединение основывается идентичности имен
столбцов в нескольких таблицах. К примеру, в таблице rental есть столбец
customer_id, выступающий внешним ключом к таблице customer, где имеется
одноименный столбец, но выступающий уже в роли первичного ключа. А это
предоставляет возможность произвести естественное соединение:

```
mysql> select c.first_name, date(r.rental_date) from customer c natural join rental r;  
Empty set (0.04 sec)
```

Случилось что- то непонятное. Почему вернулся пустой набор? А ответ заключается
в том, что и в таблице customer, и в таблице rental присутствует по столбцу
last_update:

```
mysql> desc customer;
+-------------+-------------------+------+-----+-------------------+-----------------------------------------------+
| Field       | Type              | Null | Key | Default           | Extra                                         |
+-------------+-------------------+------+-----+-------------------+-----------------------------------------------+
| customer_id | smallint unsigned | NO   | PRI | NULL              | auto_increment                                |
| store_id    | tinyint unsigned  | NO   | MUL | NULL              |                                               |
| first_name  | varchar(45)       | NO   |     | NULL              |                                               |
| last_name   | varchar(45)       | NO   | MUL | NULL              |                                               |
| email       | varchar(50)       | YES  |     | NULL              |                                               |
| address_id  | smallint unsigned | NO   | MUL | NULL              |                                               |
| active      | tinyint(1)        | NO   |     | 1                 |                                               |
| create_date | datetime          | NO   |     | NULL              |                                               |
| last_update | timestamp         | YES  |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+-------------+-------------------+------+-----+-------------------+-----------------------------------------------+
mysql> desc rental;
+--------------+--------------------+------+-----+-------------------+-----------------------------------------------+
| Field        | Type               | Null | Key | Default           | Extra                                         |
+--------------+--------------------+------+-----+-------------------+-----------------------------------------------+
| rental_id    | int                | NO   | PRI | NULL              | auto_increment                                |
| rental_date  | datetime           | NO   | MUL | NULL              |                                               |
| inventory_id | mediumint unsigned | NO   | MUL | NULL              |                                               |
| customer_id  | smallint unsigned  | NO   | MUL | NULL              |                                               |
| return_date  | datetime           | YES  |     | NULL              |                                               |
| staff_id     | tinyint unsigned   | NO   | MUL | NULL              |                                               |
| last_update  | timestamp          | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+--------------+--------------------+------+-----+-------------------+-----------------------------------------------+
```

СУБД производит объединение по customer_id, но также объединяет и по
last_update. По- сути делает это:

```
mysql> select c.first_name, date(r.rental_date) from customer c inner join rental r on c.customer_id = r.customer_id and r.last_update = c.last_update; 
Empty set (0.02 sec)
```

Единственным способом, позволяющим обойти такое огранчиение выступает
возможность ограничить столбцы как минимум в одной таблице, к примеру, через подзапрос:

```
mysql> select c.first_name, date(sr.rental_date) from customer c natural join (select rental_date, customer_id from rental) sr;
```

К счастью, Алан Болье глумится над этим способом соединения и призывает
использовать внутреннее соединение.

